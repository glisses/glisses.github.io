{"meta":{"title":"glisses","subtitle":"","description":"","author":"glisses","url":"http://glisses.github.io","root":"/"},"pages":[],"posts":[{"title":"如何准备英语面试——NUS311项目","slug":"Prepare-for-English-Interview-NUS-311-Project","date":"2022-03-30T09:09:52.000Z","updated":"2022-03-30T09:18:06.778Z","comments":true,"path":"2022/03/30/Prepare-for-English-Interview-NUS-311-Project/","link":"","permalink":"http://glisses.github.io/2022/03/30/Prepare-for-English-Interview-NUS-311-Project/","excerpt":"","text":"注意事项 特别注意自己的「声音形象（voice image）」。好的声音形象应该是自然、放松、自信的，语调、语速、音量的变化和谐。而害羞、不自信、懒散、粗心、傲慢、语速过快、紧张、无趣、犹豫不决，都会给人留下不好的印象。 第二，流利、条理、完整，缺一不可。除了英语流利度、准确度之外，条理性、完整性也很重要。 第三，投其所好。回答问题的内容，要针对公司和岗位进行调整，简单说就是要「投其所好」。还要体现你的价值：你能为公司做什么，带来什么。 第四，散发正能量。要体现积极正面的态度，避免消极。要体现你的好人品，厚道、诚实（比如谈及从上一家离职的原因）。 常用高级词句动词brag 吹嘘 Frankly speaking, I’m not the sort of people who loves bragging about myself. 坦白说，我不是喜欢自吹自擂的人。 figure 猜测 I figure it’ll rain tomorrow. 我觉得明天要下雨了。 resonate with sb. 共鸣 This just resonated with so many of my friends. 这引起了我许多朋友的共鸣。 consolidate 巩固 consolidate my professional knowledge 巩固专业知识 ​ 形容词low-key 低调的rational 理性的/合理的crucial 重要的a touch of 一点儿 用来代替a little / a bit of 的高级表达 “Chinese White Tie” means White Tie with a touch of China.中式白领结的意思就是白领结晚宴着装中融入一些中国元素。 I have a touch of flu and need some rest.我有点感冒，需要休息。 hypocritical 虚伪的thought-provoking 发人深思的 可用于不会回答的问题。 Thank you professor. Well it’s quite a thought-provoking question. However I haven’t thought about it before. So may I have one minute to think about it? 太南了，能否给我一分钟思考？ hospitable 好客的​ 副词definitely 肯定，当然​ 名词sense 感觉 Sense的意思非常多，有“……感”，“意思/意识”，“目的”等，无法和一个中文词汇完全对应。国内用到a sense of的标配经常是a sense of humor，其实它可以使用的范围非常广。 What is the sense of going out in the rain? （意为“目的”）冒雨出门到底为了啥？ The purpose of the meeting is to let you get a sense of how we work.会议的目的就是让你感受一下我们的工作模式。 Does that make sense to you?这么说你能明白么？ terminology 术语impact 影响 I’m gonna share my story as a woman in workplace and how important it is to use our voice to make an impact. 我要分享作为一个职业女性的故事，以及让女性的声音被更多人听到的重要性。 junior undergraduate 大三本科生post graduate 研究生coherence 连贯性、一致性​ 连接词Without further ado,… 废话少说，言归正传Though 尽管，表示转折There is no doubt that… 毫无疑问Frankly speaking, … 坦率地说In addition 另外大约、大概、模糊语气 approximately 大约 nearly 大约 probably 或许 almost 差不多 kind of / sort of 有点儿 or so / or something 大概 Under the guidance of Prof. Cong, I did the project for a year or so. 在丛老师的指导下，我做了一年多的项目。 ​ 句子Appreciate it! 表示感谢Have a nice day. 结束语 回答这句可以说You too. I beg your pardon? / Sorry, I didn’t follor. 没听清、没听懂，需要对方重复​ 常见问题How would you describe yourself? / Tell me about yourself. 自我介绍一下？It’s my great pleasure to interview with you. My name is Kaiang Wen, and I go by Glis.(英文名) I’m a junior undergraduate at Beijing Jiaotong University, majoring in Artificial Intelligence. As for my personality, I’m rational and determined. During my three-year study inside and outside the university, I have built up a foundation of professional knowledge, as well as rich experience of academic competitions and social activities. Personally, I’m kind-hearted, easy-going and have a sense of humor. In my spare time, I’d like to hang out with friends. Music and sports are my favorite entertainments. 家乡、特长、爱好、社团、volunteer work ​ How are you? 你好吗？I’m good. And you? ​ Where’s your hometown? / Tell me a bit about your hometown. 介绍家乡Speaking of my hometown, I have been in Guangdong for eighteen years until I went to college. Firstly, let me introduce the local language here. People in the southern provinces of Guangdong and Guangxi and in neighboring areas such as Hong Kong, usually speak Cantonese in stead of Mandarin. The word Cantonese comes from Canton, the former English name of the capital city of Guangdong. It is so different from Mandarin that we consider it a separate language. Unlike Mandarin, which has four tones, Cantonese has up to nine tones. Therefore there are so many catchy Cantonese songs. ​ If I were to travel to your hometown, where would you recommend? 我要去你家乡，你会带我去哪玩？Well, it depends. If you wanna get a taste of the traditional foods here, I would recommend you to pay a visit to Shunde City. As the saying goes, good dishes come from Guangzhou, but good cooks come from Shunde. In Shunde, you can find a lot of Mom and Pop restaurants instead of large chain restaurants. Traditional Cantonese dishes, such as 白切 chicken and Cantonese roast goose, are served there. What’s more, the price is quite reasonable. And if you wanna catch a glimpse of the natural scenery here, I would recommend you to climb Xiqiao Mountain, which is in Foshan City. Not only can you enjoy the fresh air produced by the lush forest, but you can also pay a visit to the temple there. Actually, Xiqiao Mountain holds a significant meaning in Buddhism. ​ How to acquire extracurricular knowledge? 如何获得课外知识？I’d like to answer this question in two dimensions. First, to acquire extracurricular knowledge in the field of computation, I always surf on websites like Github. Github is where programmers from around the world gather and open-source their projects. I usually look through the Github Trending to see what’s the most popular repositories currently on Github. Second, to learn things in other domains, I would like to open Zhihu app. Zhihu is usually compared to Quora in America. Well-educated people gather there to ask and answer questions. You can take it as a forum. Every topic could be on the hot chart of Zhihu. News, biochemistry breakthroughs, Internet companies laid off, and so on. ​ Why do you choose to apply for NUS? 为什么选择来NUS读研？Thank you for your question. I know a lot of people made this decision of becoming a postgraduate because of the stiff competition in today’s human resources market. But not me. I made this decision because I truly believe this is what I should do if I want to become a true research engineer in the future. During my past research projects, I have truly felt it is the lack of knowledge that stops me from doing better. That’s why I decided to apply for NUS. NUS is famous for its T-shaped educational structure. Which means broaden and deepen your knowledge. That’s what I’m looking for. This would help me develop critical thinking, raise questions and prove hypothesis. As for my long term goal, I want to further my study and apply for a PHD in the future. ​ Introduce your university. 介绍一下你的大学？Beijing Jiaotong University is a traditional university of science and technology. It holds a history of more than a hundred years. The teaching faculty there is high-standard. As long as you continue to make progress, BJTU will offer you endless help. ​ How do you see what Will Smith did on the Oscar? 如何评价奥斯卡上威尔史密斯的行为？In my point of view, both the host and Will Smith did something wrong. Can we joke on someone else’s hair loss? Well it might be impolite, but it’s not prohibited. The art of talk shows is about offending, actually. But I’m not saying what the host did is right. Because Will Smith’s wife have already said on social media that she felt down for her hair loss. So I think the host haven’t discharge his duty. However, Will Smith has done something worse. He just gave a punch. To make it worse, this is on the Oscar, a show watched by millions of people, including children and teenagers. How would this behavior influence them? Will they see violence acceptable? ​ other common question 其他常见问题 Tell me about yourself. What is your greatest strength? What is your greatest weakness? Tell me about something that’s not on your resume. How will your greatest strength help you perform? How do you handle failure? How do you handle success? Do you consider yourself successful? Why? How do you handle stress and pressure? How would you describe yourself? Describe a typical work week. Describe your work style. Do you work well with other people? Do you take work home with you? How are you different from the competition? How do you view yourself? Whom do you compare yourself to? How does this job fit in with your career plan? How many hours a week do you normally work? How would you adjust to working for a new company? How would you describe the pace at which you work? How would your co-workers describe your personality? Is there anything else we should know about you? What motivates you? Are you a self motivator? What do you find are the most difficult decisions to make? What has been the greatest disappointment in your life? What are you passionate about? What are your hobbies? What is your dream job? What will you miss most about your last job? What won’t you miss about your last job? Why are you leaving your job? Why do you want to change jobs? Why were you laid-off? Why did you quit your job? Why did you resign? What have you been doing since your last job? Why have you been out of work so long? ​ ​ References 参考资料[1] https://language.chinadaily.com.cn/2016-01/27/content_23272881.htm [2] 外企面试的时候英语自我介绍该说点什么？ - Grace的回答 - 知乎 https://www.zhihu.com/question/19666878/answer/108977620 [3] https://www.bilibili.com/video/BV1BN411o7QZ?share_source=copy_web [4] https://www.bilibili.com/video/BV1fm4y197jH?spm_id_from=333.337.search-card.all.click","categories":[],"tags":[{"name":"English","slug":"English","permalink":"http://glisses.github.io/tags/English/"}]},{"title":"包含主程序的《剑指offer》C++代码","slug":"Coding-Interviews-C++-with-main","date":"2022-02-18T14:30:16.000Z","updated":"2022-03-23T15:29:19.199Z","comments":true,"path":"2022/02/18/Coding-Interviews-C++-with-main/","link":"","permalink":"http://glisses.github.io/2022/02/18/Coding-Interviews-C++-with-main/","excerpt":"本文严格按照LeetCode上《剑指offer》学习计划的顺序撰写。代码皆为C++。 动机：LeetCode题解没有主程序，对我在本地测试造成了麻烦。想提供一份包含测试的完整程序，供大家使用。 对于《剑指offer》上的大部分题目，本文包含： 该题的LeetCode链接 解题思路（简单题可能略过） 完整代码（输入在main函数中） 样例输出 执行用时、内存消耗在LeetCode评测的排名 ​ 截至目前，本文中代码在所有CPP提交中，执行用时平均击败97.18%的用户，内存消耗平均击败78.41%的用户。 如果这篇文章对你有所帮助的话，请帮我点亮star!","text":"本文严格按照LeetCode上《剑指offer》学习计划的顺序撰写。代码皆为C++。 动机：LeetCode题解没有主程序，对我在本地测试造成了麻烦。想提供一份包含测试的完整程序，供大家使用。 对于《剑指offer》上的大部分题目，本文包含： 该题的LeetCode链接 解题思路（简单题可能略过） 完整代码（输入在main函数中） 样例输出 执行用时、内存消耗在LeetCode评测的排名 ​ 截至目前，本文中代码在所有CPP提交中，执行用时平均击败97.18%的用户，内存消耗平均击败78.41%的用户。 如果这篇文章对你有所帮助的话，请帮我点亮star! ​ Day 1剑指 Offer 09. 用两个栈实现队列【解题思路】栈的特点是先进后出，队列的特点是先进先出。 两个栈，stack1负责插入，stack2负责删除。 对于插入操作，插入stack1即可； 对于删除操作，若stack2非空，则stack2.pop()；若stack2为空，则将stack1中所有值按顺序pop到stack2中。然后stack2再pop。 【完整代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;class CQueue &#123; stack&lt;int&gt; stack1, stack2;public: CQueue() &#123; while (!stack1.empty()) stack1.pop(); while (!stack2.empty()) stack2.pop(); &#125; void appendTail(int value) &#123; stack1.push(value); &#125; int deleteHead() &#123; if (stack1.empty() &amp;&amp; stack2.empty()) return -1; if (!stack2.empty()) &#123; int ret = stack2.top(); stack2.pop(); return ret; &#125; while(!stack1.empty()) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; int ret = stack2.top(); stack2.pop(); return ret; &#125;&#125;;int main()&#123; CQueue* obj = new CQueue(); cout&lt;&lt;(obj-&gt;deleteHead())&lt;&lt;endl; obj-&gt;appendTail(5); obj-&gt;appendTail(2); cout&lt;&lt;obj-&gt;deleteHead()&lt;&lt;endl; cout&lt;&lt;obj-&gt;deleteHead()&lt;&lt;endl; return 0;&#125; 【样例输出】123-152 【执行用时、内存消耗排名】执行用时：212 ms, 在所有 C++ 提交中击败了99%的用户 内存消耗：101MB, 在所有 C++ 提交中击败了78%的用户 通过测试用例：55 / 55 ​ 剑指 Offer 30. 包含min函数的栈【解题思路】正常stack1，让stack2存放stack1中的不上升序列。注意是不上升序列而不是下降序列，不然无法处理有相同值的情况。我在这儿RE了。 【完整代码】12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;class MinStack &#123; stack &lt;int&gt; stack1, stack2;public: /** initialize your data structure here. */ MinStack() &#123; while (!stack1.empty()) stack1.pop(); while (!stack2.empty()) stack2.pop(); &#125; void push(int x) &#123; stack1.push(x); if (stack2.empty() or x&lt;=stack2.top()) stack2.push(x); &#125; void pop() &#123; if (stack2.top()==stack1.top()) stack2.pop(); stack1.pop(); &#125; int top() &#123; return stack1.top(); &#125; int min() &#123; return stack2.top(); &#125;&#125;;int main()&#123; MinStack minStack = MinStack(); minStack.push(0); minStack.push(1); minStack.push(0); cout&lt;&lt;minStack.min()&lt;&lt;endl; minStack.pop(); cout&lt;&lt;minStack.min()&lt;&lt;endl; return 0;&#125; 【样例输出】1200 【执行用时、内存消耗排名】执行用时：12ms, 在所有 C++ 提交中击败了100%的用户 内存消耗：14.6MB, 在所有 C++ 提交中击败了81%的用户 通过测试用例：19 / 19 ​ Day 2剑指 Offer 06. 从尾到头打印链表【解题思路】递归 【完整代码】12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; if (!head) return &#123;&#125;; vector &lt;int&gt; a = reversePrint(head-&gt;next); a.push_back(head-&gt;val); return a; &#125;&#125;;int main()&#123; ListNode* head = new ListNode(1); ListNode* node2 = new ListNode(3); ListNode* node3 = new ListNode(2); head-&gt;next = node2; node2-&gt;next = node3; Solution solution = Solution(); vector &lt;int&gt; ans = solution.reversePrint(head); // requires C++ 11 for (auto i = ans.begin(); i != ans.end(); i++) cout &lt;&lt; *i &lt;&lt; ' '; return 0;&#125; 【样例输出】12 3 1 【执行用时、内存消耗排名】执行用时：0ms, 在所有 C++ 提交中击败了100%的用户 内存消耗：11MB, 在所有 C++ 提交中击败了7%的用户 通过测试用例：24 / 24 ​ 剑指 Offer 24. 反转链表【解题思路】用head和tail表示已经处理好了的链表部分的头指针和尾指针。 每次将tail后的一个节点放到最前面。 【完整代码】12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;//Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; auto tail = head; while (tail &amp;&amp; tail-&gt;next) //判断tail是为了防止输入是空链表 &#123; auto swap = tail-&gt;next-&gt;next; tail-&gt;next-&gt;next = head; head = tail-&gt;next; tail-&gt;next = swap; &#125; return head; &#125;&#125;;int main()&#123; ListNode* head = new ListNode(1); ListNode* node2 = new ListNode(2); head-&gt;next = node2; ListNode* node3 = new ListNode(3); node2-&gt;next = node3; ListNode* node4 = new ListNode(4); node3-&gt;next = node4; ListNode* node5 = new ListNode(5); node4-&gt;next = node5; Solution solution = Solution(); ListNode* ans = solution.reverseList(head); // requires C++ 11 for (auto i = ans; i; i=i-&gt;next) cout&lt;&lt;i-&gt;val&lt;&lt;\"-&gt;\"; cout&lt;&lt;\"NULL\\n\"; return 0;&#125; 【样例输出】15-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 【执行用时、内存消耗排名】执行用时：4 ms, 在所有 C++ 提交中击败了94.34%的用户 内存消耗：8.1 MB, 在所有 C++ 提交中击败了61.40%的用户 通过测试用例：27 / 27 ​ 剑指 Offer 35. 复杂链表的复制【解题思路】参考了leetcode官方题解的第二种解法。 遍历链表三次： 第一遍，对每个节点产生复制节点 第二遍，处理复制节点的random指针 第三遍，分开原链表和复制链表 【完整代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std; // Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if (!head) return NULL; Node* curr = head; Node* copy = NULL; //第一遍，产生复制节点S' while (curr) &#123; copy = new Node(curr-&gt;val); copy-&gt;next = curr-&gt;next; curr-&gt;next = copy; curr = copy-&gt;next; &#125; copy = head-&gt;next; //第二遍，处理S'-&gt;random curr = head; while (curr) &#123; if (curr-&gt;random) curr-&gt;next-&gt;random = curr-&gt;random-&gt;next; // amazing curr = curr-&gt;next-&gt;next; &#125; //第三遍，分开原链表head和复制链表copy curr = head; while (curr) &#123; auto x = curr-&gt;next-&gt;next; if (x) curr-&gt;next-&gt;next = x-&gt;next; curr-&gt;next = x; curr = x; &#125; return copy; &#125;&#125;;int main()&#123; Node* head = new Node(7); Node* node1 = new Node(13); head-&gt;next = node1; Node* node2 = new Node(11); node1-&gt;next = node2; Node* node3 = new Node(10); node2-&gt;next = node3; Node* node4 = new Node(1); node3-&gt;next = node4; node1-&gt;random = head; node2-&gt;random = node4; node3-&gt;random = node2; node4-&gt;random = head; Solution solution = Solution(); Node* ans = solution.copyRandomList(head); for (auto i=ans; i; i=i-&gt;next) &#123; cout&lt;&lt;i-&gt;val&lt;&lt;\" \"; if (i-&gt;random) cout&lt;&lt;i-&gt;random-&gt;val; else cout&lt;&lt;\"NULL\"; cout&lt;&lt;endl; &#125; return 0;&#125; 【样例输出】123457 NULL13 711 110 111 7 【执行用时、内存消耗排名】执行用时：4 ms, 在所有 C++ 提交中击败了97.67%的用户 内存消耗：11 MB, 在所有 C++ 提交中击败了58.37%的用户 通过测试用例：18 / 18 ​ Day 3剑指 Offer 05. 替换空格【解题思路】没啥好说的。不过这个代码写法来自LeetCode用户Charge yourself。学习了。 【完整代码】1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: string replaceSpace(string s) &#123; string ret = \"\"; for (auto c:s) if (c==' ') ret.push_back('%'), ret.push_back('2'), ret.push_back('0'); else ret.push_back(c); return ret; &#125;&#125;;int main()&#123; Solution solution = Solution(); string s = \"We are happy.\"; cout&lt;&lt;solution.replaceSpace(s)&lt;&lt;endl; return 0;&#125; 【样例输出】1We%20are%20happy. 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：5.9 MB, 在所有 C++ 提交中击败了95.39%的用户 通过测试用例：27 / 27 ​ 剑指 Offer 58 - II. 左旋转字符串【解题思路】略 【完整代码】123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; return s.substr(n)+s.substr(0,n); &#125;&#125;;int main()&#123; Solution solution = Solution(); string s = \"abcdefg\"; int k = 2; cout&lt;&lt;solution.reverseLeftWords(s,k)&lt;&lt;endl; return 0;&#125; 【样例输出】1cdefgab 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：7.7 MB, 在所有 C++ 提交中击败了21.72%的用户 通过测试用例：34 / 34 【备注】看到一种更棒的写法： 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：7 MB, 在所有 C++ 提交中击败了88.84%的用户 通过测试用例：34 / 34 12345678910class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; n = n % s.size(); reverse(s.begin(), s.begin() + n); reverse(s.begin() + n, s.end()); reverse(s.begin(), s.end()); return s; &#125;&#125;; ​ Day 4​ 剑指 Offer 03. 数组中重复的数字【解题思路】用一个数组判断是否访问过 【完整代码】1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; vector&lt;bool&gt; vis(nums.size()); for (int i=0;i&lt;vis.size();i++) vis[i]=false; for (auto x:nums) if (!vis[x]) vis[x] = true; else return x; return -1; // denotes no repeat nums &#125;&#125;;int main()&#123; vector &lt;int&gt; nums = &#123;2, 3, 1, 0, 2, 5, 3&#125;; Solution solution = Solution(); cout&lt;&lt; solution.findRepeatNumber(nums)&lt;&lt; endl; return 0; &#125; 【样例输出】12 【执行用时、内存消耗排名】执行用时：20 ms, 在所有 C++ 提交中击败了99.25%的用户 内存消耗：22.3 MB, 在所有 C++ 提交中击败了96.92%的用户 通过测试用例：25 / 25 【备注】看到一种更棒的写法： 时间复杂度O(n)，空间复杂度O(1)。 思想是用下标进行控制，把nums[nums[i]]减掉n（即数组中数的上限）。如果某个nums[nums[i]]还没减掉n就是负数了，那就表示nums[i]重复了。 1234567891011121314class Solution &#123;public: int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i = 0; i &lt; n; i++)&#123; int k = nums[i]; if(k &lt; 0) k += n; if(nums[k] &lt; 0) return k; nums[k] -= n; &#125; return -1; &#125;&#125;; ​ 剑指 Offer 53 - I. 在排序数组中查找数字 I【解题思路】因为是有序的数组，所以可以用二分查找。 时间复杂度O(log n)，空间复杂度O(1)。 【完整代码】12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int l=0, r=nums.size()-1; if (r&lt;0) return 0; while (l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if (nums[mid]&lt;target) l=mid+1; else r=mid; &#125; if (nums[l]!=target) return 0; r = nums.size()-1; while (l&lt;r) &#123; int mid = (l+r)&gt;&gt;1; if (nums[mid]&gt;target) r=mid-1; else break; &#125; while (nums[r]!=target &amp;&amp; r&gt;=l) r--; return r-l+1; &#125;&#125;;int main()&#123; vector &lt;int&gt; nums = &#123;5,7,7,8,8,8,8,8,8,8,10&#125;;// vector &lt;int&gt; nums = &#123;&#125;; int target = 8; Solution solution = Solution(); cout&lt;&lt; solution.search(nums, target)&lt;&lt; endl; return 0; &#125; 【样例输出】17 【执行用时、内存消耗排名】执行用时：4 ms, 在所有 C++ 提交中击败了91.69%的用户 内存消耗：12.8 MB, 在所有 C++ 提交中击败了80.90%的用户 通过测试用例：88 / 88 ​ 剑指 Offer 53 - II. 0～n-1中缺失的数字【解题思路】二分。idx和nums[idx]有对应关系。 注意边界情况：即缺失数字0或数字n-1的情况。 【完整代码】12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; if (nums[0]!=0) return 0; int l=0, r=nums.size()-1; if (nums[r]==r) return r+1; while (l&lt;r) if (nums[(l+r)&gt;&gt;1]==(l+r)&gt;&gt;1) l=((l+r)&gt;&gt;1)+1; else r=(l+r)&gt;&gt;1; return l; &#125;&#125;;int main()&#123; vector &lt;int&gt; nums = &#123;0,1,2,3,4,5,6,7,9&#125;;// vector &lt;int&gt; nums = &#123;0,1&#125;; //一种很坑的情况 Solution solution = Solution(); cout&lt;&lt; solution.missingNumber(nums)&lt;&lt; endl; return 0; &#125; 【样例输出】18 【执行用时、内存消耗排名】执行用时：12 ms, 在所有 C++ 提交中击败了86.68%的用户 内存消耗：16.6 MB, 在所有 C++ 提交中击败了91.05%的用户 通过测试用例：122 / 122 Day 5​ 剑指 Offer 03. 数组中重复的数字【解题思路】从右上角开始找，每次要么左移一格，要么下移一格。时间复杂度O(n+m)。 【完整代码】12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int row = matrix.size(); if (row&lt;1) return false; int column = matrix[0].size(); if (column&lt;1) return false; int indexI = 0, indexJ = column-1; while (indexI&lt;row &amp;&amp; indexJ&gt;=0 &amp;&amp; matrix[indexI][indexJ]!=target) &#123; if (matrix[indexI][indexJ]&gt;target) indexJ--; else indexI++; &#125; return indexI&lt;row &amp;&amp; indexJ&gt;=0 &amp;&amp; matrix[indexI][indexJ]==target; &#125;&#125;;int main()&#123; Solution solution = Solution(); vector&lt;vector&lt;int&gt;&gt; matrix = &#123; &#123;1, 4, 7, 11, 15&#125;, &#123;2, 5, 8, 12, 19&#125;, &#123;3, 6, 9, 16, 22&#125;, &#123;10, 13, 14, 17, 24&#125;, &#123;18, 21, 23, 26, 30&#125; &#125;;// &#123;&#123;-5&#125;// &#125;; int target = 20; cout&lt;&lt;solution.findNumberIn2DArray(matrix, target)&lt;&lt;endl; return 0;&#125; 【样例输出】10 【执行用时、内存消耗排名】执行用时：16 ms, 在所有 C++ 提交中击败了96.93%的用户 内存消耗：12.6 MB, 在所有 C++ 提交中击败了74.41%的用户 通过测试用例：129 / 129 ​ 剑指 Offer 11. 旋转数组的最小数字【解题思路】这题虽然我一开始想到了二分，但又想了想，如果序列中绝大部分数字是重复的，就二分不了了，于是选择写线性去了。结果官方题解是二分和线性的结合体：能二分的时候二分，不能二分的时候就一个个移动。 学到了：官方题解的二分， mid=low+((high-low)&gt;&gt;1)而不是mid=(low+high)&gt;&gt;1，这是用减法来防止加法溢出。 【完整代码】线性O(n)： 123456789101112class Solution &#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; if (numbers.size()==1) return numbers[0]; if (numbers.size()==2) return min(numbers[0],numbers[1]); for (int i=0;i&lt;numbers.size()-1;i++) if (numbers[i]&gt;numbers[i+1]) return numbers[i+1]; return numbers[0]; &#125;&#125;; 二分，平均时间复杂度$O_{avg}(log_{2}x)$： 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int n = numbers.size()-1; int left = 0, right = n; // denotes the possible area of min while (left&lt;right) &#123; int mid = left + ((right-left)&gt;&gt;1); if (numbers[mid]&gt;numbers[right]) left = mid+1; else if (numbers[mid]&lt;numbers[left]) right = mid; else right--; &#125; return numbers[left]; &#125;&#125;;int main()&#123; Solution solution = Solution(); vector&lt;int&gt; numbers = &#123;2,0,1,1,1&#125;; cout&lt;&lt;solution.minArray(numbers)&lt;&lt;endl; return 0;&#125; 【样例输出】10 【执行用时、内存消耗排名】执行用时：4 ms, 在所有 C++ 提交中击败了85.51%的用户 内存消耗：11.7 MB, 在所有 C++ 提交中击败了97.55%的用户 ​ 剑指 Offer 50. 第一个只出现一次的字符【解题思路】俩数组，一个存某个字母访问了几次，一个存第一次访问该字母是在哪个位置。 visit数组用了点技巧，用vis[char-‘a’]表示访问一次以上，vis[char-‘a’+26]表示访问两次以上。 【完整代码】123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: char firstUniqChar(string s) &#123; bool vis[26+26]; int first[26]; memset(vis,false,sizeof(vis)); memset(first,0,sizeof(first)); for (int index=0; index&lt;s.length(); index++) if (vis[s[index]-'a'+26]) continue; else if (vis[s[index]-'a']) vis[s[index]-'a'+26]=true; else vis[s[index]-'a']=true, first[s[index]-'a']=index; int ans=s.length(); //s[ans] denotes the firstUnicChar for (int index=0; index&lt;26; index++) if (vis[index] &amp;&amp; !vis[index+26] &amp;&amp; first[index]&lt;ans) ans=first[index]; return (ans&lt;s.length())? s[ans] : ' '; &#125;&#125;;int main()&#123; string s = \"abaccdeff\"; Solution* solution = new Solution(); cout&lt;&lt; solution-&gt;firstUniqChar(s)&lt;&lt;endl; return 0;&#125; 【样例输出】1b 【执行用时、内存消耗排名】执行用时：12 ms, 在所有 C++ 提交中击败了97.52%的用户 内存消耗：10.3 MB, 在所有 C++ 提交中击败了90.70%的用户 通过测试用例：104 / 104 ​ Day 6​ 面试题32 - I. 从上到下打印二叉树【解题思路】bfs 【完整代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;//Definition for a binary tree node.struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; class Solution &#123;public: vector&lt;int&gt; ret; queue&lt;TreeNode*&gt; tree; vector&lt;int&gt; levelOrder(TreeNode* root) &#123; ret.clear(); while (!tree.empty()) tree.pop(); if (!root) return ret; ret.push_back(root-&gt;val); tree.push(root); while (!tree.empty()) &#123; TreeNode* curr = tree.front(); tree.pop(); if (curr-&gt;left) ret.push_back(curr-&gt;left-&gt;val), tree.push(curr-&gt;left); if (curr-&gt;right) ret.push_back(curr-&gt;right-&gt;val), tree.push(curr-&gt;right); &#125; return ret; &#125;&#125;;int main()&#123; TreeNode* root = new TreeNode(3); TreeNode* node1 = new TreeNode(9); TreeNode* node2 = new TreeNode(20); TreeNode* node3 = new TreeNode(15); TreeNode* node4 = new TreeNode(7); root-&gt;left = node1; root-&gt;right = node2; node2-&gt;left = node3; node2-&gt;right = node4; Solution solution = Solution(); for (auto x:solution.levelOrder(root)) cout&lt;&lt;x&lt;&lt;\" \"; cout&lt;&lt;endl; return 0;&#125; 【样例输出】13 9 20 15 7 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：11.6 MB, 在所有 C++ 提交中击败了98.00%的用户 通过测试用例：34 / 34 ​ 剑指 Offer 32 - II. 从上到下打印二叉树 II【解题思路】很巧妙！用每一轮队列的size来控制，将相同深度的节点放在return vector的同一层。 【完整代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;//Definition for a binary tree node.struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; queue&lt;TreeNode*&gt; tree; if (!root) return ret; tree.push(root); while (!tree.empty()) &#123; int num = tree.size(); ret.push_back(&#123;&#125;); while (num--) &#123; TreeNode* currNode = tree.front(); ret.back().push_back(currNode-&gt;val); tree.pop(); if (currNode-&gt;left) tree.push(currNode-&gt;left); if (currNode-&gt;right) tree.push(currNode-&gt;right); &#125; &#125; return ret; &#125;&#125;;int main()&#123; TreeNode* root = new TreeNode(3); TreeNode* node1 = new TreeNode(9); TreeNode* node2 = new TreeNode(20); TreeNode* node3 = new TreeNode(15); TreeNode* node4 = new TreeNode(7); root-&gt;left = node1; root-&gt;right = node2; node2-&gt;left = node3; node2-&gt;right = node4; Solution solution = Solution(); for (auto x:solution.levelOrder(root)) &#123; for (auto y:x) cout&lt;&lt;y&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; return 0;&#125; 【样例输出】12339 2015 7 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：12 MB, 在所有 C++ 提交中击败了97.90%的用户 通过测试用例：34 / 34 ​ 剑指 Offer 32 - III. 从上到下打印二叉树 III【解题思路】没啥好说的。在上一题的基础上加个reverse。 【完整代码】123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;//Definition for a binary tree node.struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; queue&lt;TreeNode*&gt; tree; if (!root) return ret; tree.push(root); bool odd = true; while (!tree.empty()) &#123; int num = tree.size(); ret.push_back(&#123;&#125;); while (num--) &#123; TreeNode* currNode = tree.front(); ret.back().push_back(currNode-&gt;val); tree.pop(); if (currNode-&gt;left) tree.push(currNode-&gt;left); if (currNode-&gt;right) tree.push(currNode-&gt;right); &#125; if (!odd) reverse(ret.back().begin(), ret.back().end()); odd^=1; &#125; return ret; &#125;&#125;;int main()&#123; TreeNode* root = new TreeNode(3); TreeNode* node1 = new TreeNode(9); TreeNode* node2 = new TreeNode(20); TreeNode* node3 = new TreeNode(15); TreeNode* node4 = new TreeNode(7); root-&gt;left = node1; root-&gt;right = node2; node2-&gt;left = node3; node2-&gt;right = node4; Solution solution = Solution(); for (auto x:solution.levelOrder(root)) &#123; for (auto y:x) cout&lt;&lt;y&lt;&lt;\" \"; cout&lt;&lt;endl; &#125; return 0;&#125; 【样例输出】123320 915 7 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：11.9 MB, 在所有 C++ 提交中击败了99.57%的用户 通过测试用例：34 / 34 ​ ​ Day 7剑指 Offer 26. 树的子结构【解题思路】递归 【完整代码】12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSameStructure(TreeNode* A, TreeNode* B) &#123; if (A == nullptr) return false; if (A-&gt;val != B-&gt;val) return false; if (B-&gt;left &amp;&amp; !isSameStructure(A-&gt;left, B-&gt;left)) return false; if (B-&gt;right &amp;&amp; !isSameStructure(A-&gt;right, B-&gt;right)) return false; return true; &#125; bool isSubStructure(TreeNode* A, TreeNode* B) &#123; if (!B) return false; if (isSameStructure(A, B)) return true; if (A-&gt;left &amp;&amp; isSubStructure(A-&gt;left, B)) return true; if (A-&gt;right &amp;&amp; isSubStructure(A-&gt;right, B)) return true; return false; &#125;&#125;; 【执行用时、内存消耗排名】执行用时：32 ms, 在所有 C++ 提交中击败了91.36%的用户 内存消耗：32.9 MB, 在所有 C++ 提交中击败了41.02%的用户 通过测试用例：48 / 48 ​ 剑指 Offer 27. 二叉树的镜像【解题思路】递归 【完整代码】1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* mirrorTree(TreeNode* root) &#123; if (root == nullptr) return nullptr; TreeNode* left = mirrorTree(root-&gt;right); TreeNode* right = mirrorTree(root-&gt;left); root-&gt;left = left; root-&gt;right = right; return root; &#125;&#125;; 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：8.9 MB, 在所有 C++ 提交中击败了64.52%的用户 通过测试用例：68 / 68 ​ 剑指 Offer 28. 对称的二叉树【解题思路】递归 【完整代码】12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isPair(TreeNode* L, TreeNode* R)&#123; if (!L &amp;&amp; !R) return true; if (!L || !R) return false; if (L-&gt;val != R-&gt;val) return false; return isPair(L-&gt;left, R-&gt;right) and isPair(L-&gt;right, R-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; if (!root) return true; return isPair(root-&gt;left, root-&gt;right); &#125;&#125;; 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：15.8 MB, 在所有 C++ 提交中击败了88.05%的用户 通过测试用例：195 / 195 ​ ​ Day 8剑指 Offer 10- I. 斐波那契数列【解题思路1】思想是用a,b两个变量，分别存储fib[n]和fib[n+1]。 从知乎上看到的，很妙的解法。时间复杂度O(N)，空间复杂度O(1)。 【完整代码1】12345678910class Solution &#123;public: int fib2(int a, int b, int n)&#123; if (n&lt;1) return a; return fib2(b, (a+b)%1000000007, n-1); &#125; int fib(int n) &#123; return fib2(0, 1, n); &#125;&#125;; 【解题思路2】把斐波那契数列的公式写成矩阵乘法的形式，然后就可以用矩阵快速幂加速，O(log N)的时间复杂度。 【完整代码2】123456789101112131415161718192021222324class Solution &#123;public: void matrixMultiply(int A[][2], int B[][2])&#123; int C[2][2]; for (int i=0;i&lt;2;i++) for (int j=0;j&lt;2;j++) C[i][j] = (1ll*A[i][0]*B[0][j] + 1ll*A[i][1]*B[1][j])%1000000007; for (int i=0;i&lt;4;i++) A[i/2][i%2]=C[i/2][i%2]; &#125; int fib(int n) &#123; int A[2][2], B[2][2]; for (int i=0;i&lt;4;i++) A[i/2][i%2]=0, B[i/2][i%2]=1; B[0][0]=0; A[0][0]=1; A[1][1]=1; while (n) &#123; if (n&amp;1) matrixMultiply(A, B); n/=2; matrixMultiply(B, B); &#125; return A[1][0]; &#125;&#125;; https://www.cnblogs.com/alexandergan/p/12225814.html中介绍了C++二维数组传参的方法 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：5.7 MB, 在所有 C++ 提交中击败了97.66%的用户 通过测试用例：51 / 51 ​ 剑指 Offer 10- II. 青蛙跳台阶问题【解题思路】与上一题基本相同。 【完整代码】12345678910class Solution &#123;public: int fib(int a, int b, int n)&#123; if (n&lt;1) return a; return fib(b, (a+b)%1000000007, n-1); &#125; int numWays(int n) &#123; return fib(1, 1, n); &#125;&#125;; 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：5.8 MB, 在所有 C++ 提交中击败了72.21%的用户 通过测试用例：51 / 51 ​ 剑指 Offer 63. 股票的最大利润【解题思路】如果必在第i天出售，则在前i-1天中股票最低价时购入是最划算的。贪心。 【完整代码】1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int min_price = 1e9, ans = 0; for (auto price:prices)&#123; ans = max(ans, price-min_price); min_price = min(min_price, price); &#125; return ans; &#125;&#125;; 【执行用时、内存消耗排名】执行用时：4 ms, 在所有 C++ 提交中击败了88.50%的用户 内存消耗：12.4 MB, 在所有 C++ 提交中击败了86.17%的用户 通过测试用例：200 / 200 ​ Day 9剑指 Offer 42. 连续子数组的最大和【解题思路】贪心。负滴不要。 【完整代码】1234567891011class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int ans=nums[0], sum=nums[0]; for (int i=1; i&lt;nums.size(); i++) &#123; sum = max(sum+nums[i], nums[i]); ans = max(ans, sum); &#125; return ans; &#125;&#125;; 【执行用时、内存消耗排名】执行用时：12 ms, 在所有 C++ 提交中击败了95.54%的用户 内存消耗：22.3 MB, 在所有 C++ 提交中击败了82.43%的用户 通过测试用例：202 / 202 ​ 剑指 Offer 47. 礼物的最大价值【解题思路】经典的dp问题。 【完整代码】12345678910111213class Solution &#123;public: int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); for (int i=1; i&lt;m; i++) grid[i][0] += grid[i-1][0]; for (int j=1; j&lt;n; j++) grid[0][j] += grid[0][j-1]; for (int i=1; i&lt;m; i++) for (int j=1; j&lt;n; j++) grid[i][j] += max(grid[i-1][j], grid[i][j-1]); return grid[m-1][n-1]; &#125;&#125;; 【执行用时、内存消耗排名】执行用时：4 ms, 在所有 C++ 提交中击败了95.48%的用户 内存消耗：8.8 MB, 在所有 C++ 提交中击败了93.37%的用户 通过测试用例：61 / 61 ​ ​ Day 10剑指 Offer 46. 把数字翻译成字符串【解题思路】简单动态规划。 备注：题解用了to_string()，省去了我把num拆成每一位放进a数组的过程。 【完整代码】1234567891011121314151617181920class Solution &#123;public: int translateNum(int num) &#123; if (num&lt;10) return 1; int cnt=0; vector&lt;int&gt; a(10); while (num) a[cnt++]=num%10, num/=10; for (int i=0;i&lt;(cnt+1)/2;i++) swap(a[i],a[cnt-i-1]); int p = 1; int q = (a[0]!=0 &amp;&amp; a[0]*10+a[1]&lt;26)? 2:1; for (int i=2;i&lt;cnt;i++) &#123; int x = p; p = q; if (a[i-1]!=0 &amp;&amp; a[i-1]*10+a[i]&lt;26) q += x; &#125; return q; &#125;&#125;; 【执行用时、内存消耗排名】执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：5.7 MB, 在所有 C++ 提交中击败了97.49%的用户 通过测试用例：49 / 49 ​ 剑指 Offer 48. 最长不含重复字符的子字符串【解题思路】我写了一个很丑的orz 因为这题有坑，字符串不只包含a~z，还可能有空格啥的。我为了处理未知的字符，用了map。 然后去题解那里一看，原来C++的数组下标也可以是字符，会转成对应的ASCII码。 【我的代码】12345678910111213141516171819202122class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; map&lt;char, int&gt; indexOfChar; int ans = 0, left = 0, right = 0; while (right &lt; s.length()) &#123; char c = s[right]; if (indexOfChar.find(c) == indexOfChar.end()) &#123; indexOfChar[c] = right; right++; continue; &#125; ans = max(ans, right-left); for (int j = left; j&lt;indexOfChar[c]; j++) indexOfChar.erase( indexOfChar.find(s[j]) ); left = indexOfChar[c]+1; indexOfChar[c] = right++; &#125; return max(int(s.length())-left, ans); &#125;&#125;; 【题解代码】123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; dp(128,-1);//存储每个字符最后出现的位置 int i=0,j=0,res=0; for(;j&lt;s.size();j++)&#123; if(dp[s[j]]&lt;i)//前面的子串不含新加的字符 res=max(res,j-i+1); else//当前字符在之前的子串中出现过 i=dp[s[j]]+1;//更新i，使得i到j没有重复字符 dp[s[j]]=j;//更改当前字符出现的位置 &#125; return res; &#125;&#125;; 【执行用时、内存消耗排名】执行用时：4 ms, 在所有 C++ 提交中击败了97.83%的用户 内存消耗：7.6 MB, 在所有 C++ 提交中击败了80.13%的用户 通过测试用例：987 / 987 ​ ​ ​ 其他32. 最长有效括号【解题思路】用counter记录，遇到左括号就+1，遇到右括号就-1。 用数组index[x]存放counter值为x时的合法字符串的左端点下标。 如果遇到一个右括号，那么index[counter+2]就会变得不合法。不合法记为1e9。 由于这个过程中，counter可能因为右括号很多而变为负数，所以用counter_convert存放取模后的值。 【完整代码】123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;class Solution &#123;public: int index[30001]; int longestValidParentheses(string s) &#123; int counter = 0; int ans = 0; // length of the longest valid parentheses int n = s.length(); for (int i=0; i&lt;n+1; i++) index[i]=1e9; for (int i=0; i&lt;s.length(); i++)&#123; char c = s[i]; assert (c=='(' or c==')'); // only () in the string counter = (c=='(')? counter+1 : counter-1; int counter_convert = (counter+n)%n; // to avoid negative index if (c==')')&#123; ans = max(ans, i-index[(counter_convert+1)%n]+1); index[(counter_convert+2)%n] = 1e9; // becomes invalid &#125; else index[counter_convert] = min(index[counter_convert], i); &#125; return ans; &#125;&#125;;int main()&#123; string s = \")()())\"; Solution solution = Solution(); cout&lt;&lt;solution.longestValidParentheses(s)&lt;&lt;endl; return 0;&#125; 【样例输出】14 【执行用时、内存消耗排名】时间和空间复杂度都是O(n) 执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户 内存消耗：6.7 MB, 在所有 C++ 提交中击败了86.75%的用户 模板​ 剑指 Offer 09. 用两个栈实现队列【解题思路】【完整代码】12 【样例输出】12 【执行用时、内存消耗排名】","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"ssh:The authenticity of host 'hostname' can't be established","slug":"ssh-The-authenticity-of-host-hostname-can-t-be-established","date":"2022-02-18T09:05:39.000Z","updated":"2022-02-18T09:27:32.091Z","comments":true,"path":"2022/02/18/ssh-The-authenticity-of-host-hostname-can-t-be-established/","link":"","permalink":"http://glisses.github.io/2022/02/18/ssh-The-authenticity-of-host-hostname-can-t-be-established/","excerpt":"前言组里的服务器重装系统了。我在ssh连接服务器时出现提示ssh:The authenticity of host &#39;hostname&#39; can&#39;&#39;t be established。如图： 在用vscode的remote ssh连接时也报错Could not establish connection to &#39;hostname&#39;。","text":"前言组里的服务器重装系统了。我在ssh连接服务器时出现提示ssh:The authenticity of host &#39;hostname&#39; can&#39;&#39;t be established。如图： 在用vscode的remote ssh连接时也报错Could not establish connection to &#39;hostname&#39;。 ​ 报错原因重装系统后，服务器的key发生了变化，因此每次ssh连接都会有提示。 ​ 解决方案修改vscode上ssh的config文件，在对应的Host下面加上两行 12StrictHostKeyChecking=noUserKnownHostsFile=/dev/null 该命令是让ssh不再严格检查服务器的key。当然，这种简单粗暴的做法也是有风险的。 如下图： 这时就可以像以前一样，用vscode远程连接服务器了。 ​ 参考资料 [1] https://blog.csdn.net/qq_21480607/article/details/91845794 [2] https://stackoverflow.com/questions/3663895/ssh-the-authenticity-of-host-hostname-cant-be-established","categories":[],"tags":[{"name":"error","slug":"error","permalink":"http://glisses.github.io/tags/error/"}]},{"title":"【转载】pip批量升级所有库(包)","slug":"pip升级所有库-包","date":"2022-02-05T04:05:49.000Z","updated":"2022-02-05T04:13:51.901Z","comments":true,"path":"2022/02/05/pip升级所有库-包/","link":"","permalink":"http://glisses.github.io/2022/02/05/pip%E5%8D%87%E7%BA%A7%E6%89%80%E6%9C%89%E5%BA%93-%E5%8C%85/","excerpt":"版权声明：本文为CSDN博主「折纸之泪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/Java_web12138667/article/details/110739978 ​ 前言使用pip工具管理第三方库，升级方式。 确定pip版本，如果使用的pyton2，也就是默认的python，那么pip就使用默认的pip；如果使用的python3，那么pip也需要使用pip3。 我使用的是python3+pip3。","text":"版权声明：本文为CSDN博主「折纸之泪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/Java_web12138667/article/details/110739978 ​ 前言使用pip工具管理第三方库，升级方式。 确定pip版本，如果使用的pyton2，也就是默认的python，那么pip就使用默认的pip；如果使用的python3，那么pip也需要使用pip3。 我使用的是python3+pip3。 ​ pip版本首先确保pip的版本是可用的，确保升级库过程中不会报错。查看pip版本： 1pip3 --version 如果在安装库的过程中，出现以下提示说明pip版本过低，需要升级了。WARNING: You are using pip version 20.2.4; however, version 20.3.1 is available. 升级pip31sudo python3 -m pip install --upgrade pip 接下再升级 ​ 查看所有可以升级的python库1pip3 list --outdated ​ 升级单个库1pip3 install --upgrade 库名 ​ 批量升级库如果需要升级的库数量很多，先然这个方式行不通。 批量升级库的方式： 1. 借助第三方库安装pip-review，这个python的一个第三方库，注意：这个库名就叫做pip-review，不区分pip与pip3。安装语句： 1pip3 install pip-review 升级全部库: 1pip-review --local --interactive 输入A，全部升级即可。 ​ 2. python脚本方式创建一个python文件，输入以下内容： 12345import pkg_resourcesfrom subprocess import callfor packages in [dist.project_name for dist in pkg_resources.working_set]: call(\"pip3 install --upgrade \" + ''.join(packages) + ' --user', shell=True) 运行该脚本即可升级全部库。","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"矩阵求导公式的数学推导","slug":"矩阵求导公式的数学推导","date":"2022-01-19T06:30:46.000Z","updated":"2022-01-21T12:28:49.564Z","comments":true,"path":"2022/01/19/矩阵求导公式的数学推导/","link":"","permalink":"http://glisses.github.io/2022/01/19/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F%E7%9A%84%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC/","excerpt":"矩阵求导公式推导","text":"矩阵求导公式推导 ​ 公式一 其中，α为常数列向量。 证明： 公式二 其中，A是常数矩阵， 证明： 公式三 证明：由于 故 公式四 由 暴力证明即可，略。 ​ 参考资料 【1】Iterator，矩阵求导公式的数学推导（矩阵求导——基础篇），https://zhuanlan.zhihu.com/p/273729929 【2】wongHome，使用Typora添加 行内、行间 数学公式，https://blog.csdn.net/qq_39779233/article/details/107772793 【3】Anne033，矩阵迹（trace）, 行列式（determinate），https://blog.csdn.net/Anne033/article/details/108915986 【4】Iterator，矩阵求导公式的数学推导（矩阵求导——进阶篇），https://zhuanlan.zhihu.com/p/288541909 【5】Chris Taylor，https://math.stackexchange.com/questions/38701/how-to-calculate-the-gradient-of-log-det-matrix-inverse 【6】Deep Reader，github上Markdown不支持LaTeX吗？ - Deep Reader的回答 - 知乎 ，https://www.zhihu.com/question/26887527/answer/43166739","categories":[],"tags":[{"name":"math","slug":"math","permalink":"http://glisses.github.io/tags/math/"}]},{"title":"conda创建python2环境并解决IOLoop初始化失败的问题","slug":"conda创建python2环境并解决IOLoop初始化失败的问题","date":"2022-01-15T05:47:01.000Z","updated":"2022-01-15T06:15:13.673Z","comments":true,"path":"2022/01/15/conda创建python2环境并解决IOLoop初始化失败的问题/","link":"","permalink":"http://glisses.github.io/2022/01/15/conda%E5%88%9B%E5%BB%BApython2%E7%8E%AF%E5%A2%83%E5%B9%B6%E8%A7%A3%E5%86%B3IOLoop%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"前情提要Glis在看一个挺好的教程CS228 Python Tutorial，但原版是python2.7的。 NodYoung等改写了一个python3版本的cs228-python-tutorial.ipynb。 同时，Glis也想记录一下用conda创建python2环境的过程，和途中遇到的问题。 ​ conda创建python2环境​ 1. 显示可安装的python版本1conda search -f python ​ 2. 安装虚拟环境，名称为py2，版本为上一步中你有的python2版本1conda create -n py2 python=2.7 ​","text":"前情提要Glis在看一个挺好的教程CS228 Python Tutorial，但原版是python2.7的。 NodYoung等改写了一个python3版本的cs228-python-tutorial.ipynb。 同时，Glis也想记录一下用conda创建python2环境的过程，和途中遇到的问题。 ​ conda创建python2环境​ 1. 显示可安装的python版本1conda search -f python ​ 2. 安装虚拟环境，名称为py2，版本为上一步中你有的python2版本1conda create -n py2 python=2.7 ​ 3. 激活虚拟环境py21conda activate py2 ​ 运行教程.ipynb文件​ 1. 安装ipykernel1conda install -c conda-forge --name py2 ipykernel -y ​ 2. 报错：AttributeError：type object IOLoop has no attribute initializedIOLoop没有初始化成是因为tornado的版本过高导致的。 1pip list 可以看到我的tornado版本是5.1.1 ​ 3. 降级tornado1pip uninstall tornado 此时可以再用pip list，确认tornado已被卸载。 1pip list 安装4.4.3版本的tornado 1pip install tornado==4.4.3 ​ 4.运行教程 参考资料https://blog.csdn.net/Joyyang_c/article/details/108486172","categories":[],"tags":[{"name":"codes","slug":"codes","permalink":"http://glisses.github.io/tags/codes/"}]},{"title":"使用清华镜像安装python包","slug":"使用清华镜像安装python包","date":"2022-01-13T12:12:59.000Z","updated":"2022-01-13T12:16:04.713Z","comments":true,"path":"2022/01/13/使用清华镜像安装python包/","link":"","permalink":"http://glisses.github.io/2022/01/13/%E4%BD%BF%E7%94%A8%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85python%E5%8C%85/","excerpt":"","text":"在以后安装包的时候可以先在 cmd 中输入以下命令 123config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/config --set show_channel_urls yes conda config --set show_channel_urls yes的意思是从channel中安装包时显示channel的url，这样就可以知道包的安装来源了。 然后就可以使用清华镜像进行包的安装，终于可以看着进度条刷刷刷地走了。","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"Mycli-MySQL命令行在客户端自动补全、语法高亮","slug":"Mycli-MySQL命令行在客户端自动补全、语法高亮","date":"2021-11-30T12:12:34.000Z","updated":"2021-11-30T12:25:34.737Z","comments":true,"path":"2021/11/30/Mycli-MySQL命令行在客户端自动补全、语法高亮/","link":"","permalink":"http://glisses.github.io/2021/11/30/Mycli-MySQL%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E3%80%81%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE/","excerpt":"安装pip安装1$ pip3 install mycli ​ ubuntu安装12$ sudo apt-get update$ sudo apt-get install mycli ​ Mac安装1$ brew install mycli ​ 使用示例windows​ 语法高亮","text":"安装pip安装1$ pip3 install mycli ​ ubuntu安装12$ sudo apt-get update$ sudo apt-get install mycli ​ Mac安装1$ brew install mycli ​ 使用示例windows​ 语法高亮 自动补全","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"Otsusu-A threshold selection method from gray level histograms","slug":"Otsusu-A-threshold-selection-method-from-gray-level-histograms","date":"2021-11-28T13:42:39.000Z","updated":"2021-11-28T13:50:52.681Z","comments":true,"path":"2021/11/28/Otsusu-A-threshold-selection-method-from-gray-level-histograms/","link":"","permalink":"http://glisses.github.io/2021/11/28/Otsusu-A-threshold-selection-method-from-gray-level-histograms/","excerpt":"","text":"论文地址：https://www.semanticscholar.org/paper/A-threshold-selection-method-from-gray-level-Otsu/1d4816c612e38dac86f2149af667a5581686cdef#extracted ​ Otsu是一种图像二值化阈值的选择方法，由日本学者OTSU于1979年提出并发表在IEEE Trans，别名大津法、最大类间方差法。 它的主要思想是：对于一个阈值，可以把图片中的所有像素分为两类。把第一类的像素都修改成第一类的像素的均值，第二类也修改成第二类像素的均值，求这张二值化图片的方差。Otsu所找的阈值，就是使这个类间方差最大的阈值。阈值一共也就0~255这么多种，遍历一遍完事。 ​","categories":[],"tags":[{"name":"paper reading","slug":"paper-reading","permalink":"http://glisses.github.io/tags/paper-reading/"}]},{"title":"python中出现IndentationError:unindent does not match any outer indentation level错误【转载】","slug":"python中出现IndentationError-unindent-does-not-match-any-outer-indentation-level错误","date":"2021-10-10T05:36:51.000Z","updated":"2021-10-10T05:46:47.598Z","comments":true,"path":"2021/10/10/python中出现IndentationError-unindent-does-not-match-any-outer-indentation-level错误/","link":"","permalink":"http://glisses.github.io/2021/10/10/python%E4%B8%AD%E5%87%BA%E7%8E%B0IndentationError-unindent-does-not-match-any-outer-indentation-level%E9%94%99%E8%AF%AF/","excerpt":"版权声明：本文为CSDN博主「HelloWorld_EE」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u010412719/article/details/47089473 ​ python中出现IndentationError:unindent does not match any outer indentation level今天在网上copy的一段代码，代码很简单，每行看起来该缩进的都缩进了，运行的时候出现了如下错误： 12345# 这是Glis遇到的报错 File \"xxx.py\", line 254 pdb.set_trace() ^IndentationError: unindent does not match any outer indentation level","text":"版权声明：本文为CSDN博主「HelloWorld_EE」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u010412719/article/details/47089473 ​ python中出现IndentationError:unindent does not match any outer indentation level今天在网上copy的一段代码，代码很简单，每行看起来该缩进的都缩进了，运行的时候出现了如下错误： 12345# 这是Glis遇到的报错 File \"xxx.py\", line 254 pdb.set_trace() ^IndentationError: unindent does not match any outer indentation level ​ 【解决过程】1.对于此错误，最常见的原因是，的确没有缩进。根据错误提示的行数，去代码中看了下，看起来没有什么问题呀，都有缩进，而且语法也没有错误呀。 2.仔细研究了下代码，发现真的看不出什么问题，突然想到了，把当前python脚本的所有字符（包括空格和tab字符）都显示出来看看到底有没有缩进或者是其他特殊的字符。 当前用的文本编辑器Notepad++，有个设置，可以显示所有的字符的。在：视图 –&gt; 显示符号 –&gt; 显示空格与制表符这样就可以看到我们Python代码的到底有没有该缩进的都缩进了。 最终发现代码报错原因还真是出在这里，错误提示的这行看起来是缩进了，实际上确没有缩进，这就是问题的根源所在。 发现了个问题，发现copy过来的Python代码都没有进行缩进，当我们copy别人的代码时，缩进这点需要额外注意。不要看起来代码缩进了就感觉ok了，实际上是没有缩进的。 注：copy过来的一般都是两个空格字符，确实不是缩进符，但看起来却像缩进了一样。 ​ 【评论区其他方法】 1pip install black &amp;&amp; balck your_python_code.py","categories":[],"tags":[{"name":"python error","slug":"python-error","permalink":"http://glisses.github.io/tags/python-error/"}]},{"title":"数据库系统原理课堂笔记","slug":"数据库系统原理课堂笔记","date":"2021-09-21T07:16:09.000Z","updated":"2021-10-06T16:44:56.250Z","comments":true,"path":"2021/09/21/数据库系统原理课堂笔记/","link":"","permalink":"http://glisses.github.io/2021/09/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"课程基本信息教师：林友芳 办公地点：计算中心300 邮箱：yflin@bjtu.edu.cn 教材： 课程安排","text":"课程基本信息教师：林友芳 办公地点：计算中心300 邮箱：yflin@bjtu.edu.cn 教材： 课程安排 &nbsp; 分数构成 平时分 考勤、作业 50 期末考试 客观题（考察概念） 25 主观题 25 &nbsp; 慕课https://www.icourse163.org/learn/NJTU-1450818183?tid=1464964445#/learn/content &nbsp; 作业详细信息要求学生掌握四层以上架构数据库系统全栈编程技术。培养学生复杂系统设计与编程实现能力，树立技术自信，有效串接多科知识。 &nbsp; 第一章 数据库系统概述&nbsp; 本章主要教学内容 &nbsp; 第一节 数据库的四个基本概念 数据（Data） 数据库（Database, DB） 数据库系统（Database System, DBS） 数据库管理系统（Database Management System, DBMS） 这四个概念之间关系的语义网络： &nbsp; 数据数是符号，据是凭据。 数据，是记录下来当成凭据的符号。 这个理解挺有意思。 &nbsp; 数据库数据库与水库类比： 水库：有需求，有水源，有设施，有空间，实现水流控制，有组织，有管理，可共享，有服务，服务于不同的目的 数据库：有需求，有数据源，有设施，有空间，实现数据控制，有组织，有管理，可共享，有服务，服务于不同的目的 数据库的定义A database is an organized collection of data. Formally, a “database” refers to a set of related data and the way it is organized. 数据库是长期存放在计算机内、有组织的、可共享的数据集合。 数据库中的数据按一定的数据模型组织、描述和存储，且具有较小的冗余度、较高的数据独立性和易扩展性，并可为多个用户共享。 &nbsp; 数据库管理系统数据库管理系统的定义A database-management system (DBMS) is a computer software application that interacts with end-users, other applications, and the database itself to capture, provide access to and analyze data. 数据库管理系统是用于建立、使用和维护数据库的软件。 “建立”：如何定义、组织和存储数据 “使用”：查询、插入、删除和修改数据 “维护”：保证数据的安全性、完整性 &nbsp; 数据库管理系统的位置与功能 &nbsp; 数据库系统数据库系统的定义采用了数据库技术的计 算机系统，包括DB、 DBMS、开发工具、 应用系统、硬件、软件、 用户和DBA（数据库管理员）。 &nbsp; 数据处理与数据管理【数据处理】: 是对各种形式的数据进行收集、储存、加工、 管理和传播的一系列活动的总和。 【数据管理】： 是指数据的分类、组织、编码、存储、维护、 检索等操作，是数据处理的核心。 数据的管理经历了多个阶段。 &nbsp; 第二节 数据管理技术的发展阶段 &nbsp; 先聊聊磁带。磁带是顺序存取数据的。也就是说，即使我们知道数据在哪里，也要先按顺序，倒带到那个位置，再存取数据（比如说播放录音）。 直接存取则是知道了地址，就可以取出该地址的内容了。 虽然磁带是顺序存储的，速度慢且体积大，但磁带依然又它的地位。因为磁带的存储寿命较长，而且维护成本低廉——不用插电，只要找个地方放磁带就行。 参考资料 https://zh.wikipedia.org/wiki/%E7%A3%81%E5%B8%A6 &nbsp; 人工管理阶段 特点 数据不长期保存 应用程序管理数据 没有专有的软件对数据进行管理, (应用程序要规定数据的逻辑结构和物理结构，包括存储结构，存取方法，输入方式)。 数据不具有独立性 数据的逻辑结构或物理结构发生变化后，必须对应用程序做相应的修改。 数据不共享 数据面向程序，即一组数据对应一个程序，当多个应用涉及相同 数据时，程序之间有大量的冗余数据。 【自己的补充】 数据独立性，指应用程序和数据结构之间相互独立，一方改变，另一方不需要如何改变。 正是三级模式间的两层映像保证了数据库系统中的数据具有较高的数据独立性。 数据独立性包括数据逻辑独立性和数据物理独立性。 但我们追求的不是绝对独立，而是相对独立。 &nbsp; 文件系统阶段 &nbsp; 【自己的补充】 批处理(Batch)，也称为批处理脚本。 顾名思义，批处理就是对某对象进行批量的处理，通常被认为是一种简化的脚本语言，它应用于DOS和Windows系统中。 批处理文件的扩展名为bat 。目前比较常见的批处理包含两类：DOS批处理和PS批处理。 PS批处理是基于微软的强大的PowerShell的，用来批量处理一些任务的脚本；而DOS批处理则是基于DOS命令的，用来自动地批量地执行DOS命令以实现特定操作的脚本。 更复杂的情况，需要使用if、for、goto等命令控制程式的运行过程，如同C、Basic等高级语言一样。如果需要实现更复杂的应用，利用外部程式是必要的，这包括系统本身提供的外部命令和第三方提供的工具或者软件。 批处理程序虽然是在命令行环境中运行，但不仅仅能使用命令行软件，任何当前系统下可运行的程序都可以放在批处理文件中运行。 并行处理（Parallel Processing）是计算机系统中能同时执行两个或多个处理的一种计算方法。 并行处理可同时工作于同一程序的不同方面。并行处理的主要目的是节省大型和复杂问题的解决时间。为使用并行处理，首先需要对程序进行并行化处理，也就是说将工作各部分分配到不同处理进程（线程）中。 并行处理由于存在相互关联的问题，因此不能自动实现。另外，并行也不能保证加速。从理论上讲，在 n 个并行处理的执行速度可能会是在单一处理机上执行的速度的 n 倍。 分布式处理（distributed processing）和并行处理（Parallel processing）是为了提高并行处理速度采用的两种不同的体系架构。 并行处理是利用多个功能部件或多个处理机同时工作来提高系统性能或可靠性的计算机系统，这种系统至少包含指令级或指令级以上的并行。 分布式处理则是将不同地点的，或具有不同功能的，或拥有不同数据的多台计算机通过通信网络连接起来，在控制系统的统一管理控制下，协调地完成大规模信息处理任务的计算机系统。 并行处理与分布式处理的区别 并行处理与串行处理相对。也就是说，在有多个任务时，串行处理是一个接一个地处理，而并行处理是同时做这多个任务。并行处理包括多线程。 而分布式处理与单个计算机处理相对。它强调的是多台计算机。 所以说，分布式处理和并行处理是在两个不同的维度。用多台计算机，然后同时处理，那就是并行处理和分布式处理都有。 联机实时处理 请求的接受和处理都是实时的，一旦处理完成后就要实时将处理结果传给用户。所以，联机实时处理对处理速度有较高要求。 脱机处理 早期 早期用手工操作方式使用计算机时，操作和输入输出都是联机的，由中央处理机直接控制完成，作业时间很长（见联机处理）。 脱机处理技术的出现 随着计算机速度不断提高，中央处理机在输入输出操作时要等待慢速的联机输入输出设备，不能充分发挥应有的效率。为此，在批处理中引入了脱机输入输出：在主机之外另设一台小型微型机，该机只与外部设备打交道，把要处理的信息成批地输入到高速的辅助存储器（磁带或磁盘）中，再把辅助存储器与主机连接起来。主机仅从高速的辅助存储器中调入信息进行处理，作业完成后，处理结果和有关信息以文件形式存于辅助存储器中，然后再把它们转移到微型机去输出。 微型机的特点 工作完全独立于主机进行，使主机能摆脱慢速的输入输出工作的牵制。如果输入输出任务繁重，则可配置若干台微型机，一些专门从事脱机输入，另一些专门从事脱机输出。 参考资料 https://blog.csdn.net/Vinsuan1993/article/details/72959235 &nbsp; 特点（要理解） 数据可长期保存 在外存的磁盘中 由文件系统管理数据 实现按文件名访问,按记录存取。 数据共享性差，冗余度大 一个文件基本上对应一个应用程序，不同的应用程序具有相同的数据时,造成数据的冗余，以及由于重复存储，各自管理造成数据 的不一致性。 数据独立性差 一旦数据的逻辑结构改变,必须修改应用程序,修改文件结构的 定义。因此数据与程序之间仍缺乏独立性。 第一节课到此结束 &nbsp; 数据库系统阶段数据管理技术进入数据库阶段的标志，是1960年代 末发生的三件大事： 1968年，美国IBM公司推出层次模型的IMS系统 1969年，美国数据系统语言协会(CODASYL)的数据库任 务组（DBTG)发表关于网状模型的DBTG报告（1971年通 过） 1970年，美国IBM公司的E.F. Codd提出关系模型，奠定 了关系数据库的理论基础。 特点 数据结构化 数据模型不仅描述数据本身的特点，还描述数据 之间的联系。整体数据结构化。不仅数据是结构化的， 存取数据的方式也灵活。 数据共享性高, 冗余度低, 易扩充 数据是面向整个系统，不是面向应用的，所以多应 用多用户可共享数据，减少冗余，避免数据的不一致 性。容易增加新的应用，易于扩充。 数据独立性高—包括物理独立性和逻辑独立性。 指数据在磁盘上的物理存储改变和逻辑结构改变，应用程序可能可以不用变。 数据独立性由DBMS的二级映象功能保证。数据与程序独立,把数据的定义从程序中分离,简化程序的编制、维护和修改工作。 数据由DBMS统一管理和控制 DBMS提供四个方面的数据控制功能： 数据的恢复、并发控制数据完整性和数据安全性。 这个统一管理，可以理解为： ​ 数据不能走后门，都要先通过DBMS，再通过操作系统，到达数据库。不能绕过其中的某一步。 可以和文件系统阶段的特点对比一下 &nbsp; 三级模式，两层映像 三级模式两层映射的好处是： 物理数据独立性 当用户的局部逻辑结构改变，只需要改变其和数据库的映射关系，数据库里数据的地址不用变动。用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的。 逻辑数据独立性 同样的，当数据库的物理结构改变，用户的局部逻辑结构也不需要变动。即修改了数据库的逻辑模式，也不必重写应用程序。 &nbsp; 数据库系统与传统文件系统的根本区别 在文件系统中，记录内部有了某些结构，但记录之间没有联系。数据库系统实现整体数据结构化。 “整体结构化”是指： 数据库中的数据不再仅仅针对某个应用，而是面向全组织（企业）； 不仅数据内部是结构化的，而且整体是结构化的， 数据之间是具有联系的。 数据存取对象层级类型不同 在文件系统中, 数据的最小存取单位是一般是记录, 粒度不能细到数据项。 数据库系统中可以存取数据库中某一个数据项, 一组数据 项, 一个记录, 一组记录。 &nbsp; 高级数据库技术阶段 &nbsp; 【自己的补充】 BigTableBigtable分布式数据存储系统是Google为其内部海量的结构化数据开发的云存储技术，是Google的第三项云计算关键技术，是所有云时代分布式存储系统的开发蓝本，已经在超过60个Google的产品和项目上得到了应用。 Bigtable的设计是为了能可靠地处理PB级的海量数据，使其能够部署在千台机器上。Bigtable具有高可靠性、高性能、可伸缩等特性，借鉴了并行数据库和内存数据库的一些特性，但Bigtable提供了一个完全不同接口。Bigtable不支持完整的关系数据模型，而是为用户提供了简单的数据模型，使客户可以动态控制数据的分布和格式。 &nbsp; 第三节 数据模型什么是模型 &nbsp; 数据模型的定义数据模型也是一种模型，是现实世界数据特征的抽象。 A data model an abstract model that organizes elements of data and standardizes how they relate to one another and to properties of the real world entities. 抽象：抽，提取；抽象的过程中，会撇去不重要的东西，得到共性的东西。可以层层抽象。 从英文来看，摘要abstract，抽象abstract。（当然，这只是抽象的其中一个意思） 从用途的角度进行定义： 数据模型是用于描述现实世界，指导数据的设计 、存储，并作为数据设计结果的检验标准的模型。 &nbsp; 数据模型相关概念 数据模型应满足三个要求: 真实地模拟现实世界 容易理解 便于计算机上实现 数据模型相关概念 数据模型的层次 概念、逻辑、物理；高层、中间层、低层 OLTP层、数据集成层、ODS或近线层、数据仓库层或离线层 数据模型的描述工具 数据模型的通用性 行业数据模型、企业级数据模型 主题数据模型、Featuring、Model Embeeding, 自动建模、 &nbsp; 数据模型三个组成部分 数据结构: 是所研究对象类型的集合，即对实体类型和实体间联系的表达和实现，是系统静态特征的描述。 数据操作: 是指对数据库中各对象允许执行的操作的集合，包括检索和更新两类，是系统动态特征的描述。(操作 是否归入数据模型有争议) 数据完整性约束: 给出数据及其联系应具有的制约和依存规则，保证数据的正确、有效、相容。有实体完整性、 参照完整性和用户定义的完整性。 &nbsp; 数据模型设计 &nbsp; 数据模型相关的三个世界或领域 &nbsp; &nbsp; 第二节课到此结束 &nbsp; 概念模型 概念模型的功能 在信息世界里对现实世界进行建模 表达现实世界中的概念 表达概念之间的关系 表达业务领域的语义知识 对概念模型的要求 具有很强的表达能力–能力强 易于理解—容易懂 简单—容易画 概念模型的定义及特点为正确直观地反映客观事物及其联系，对所研究的信息世界，按用户观点对数据和信息建模型，称之为概念模型。(用于数据库设计) 特点： 是独立于计算机系统的模型，完全不涉及信息在系统中的表示 用于建立信息世界的数据模型，是现实世界的第一层抽象（是 现实到机器的中间层） 强调语义表达功能，概念简单、清晰，易于用户理解，是用户 和DB设计人员之间交流的语言,是DB设计人员进行数据库设计的工具 1、信息世界的术语 实体—entity 可以相互区别的客观事物和概念的抽象，如人，学生，教师，… 属性—attribute 对实体某一特征的描述，如学号，姓名，年龄，… 域—domain，属性定义域 属性取值范围，如年龄：[0, 200] 实体的码、实体标识符—entity key or identifier 能唯一标识每个实体的属性集，如：学号 实体型—entity type or entity schema，实体模式，实体类型 用实体名及其属性名的集合来抽象和刻画同类实体，称为实体型。 学生（学号，姓名） 实体集—entity set 性质相同的同类实体的集合 联系—relationship，关系 分成两类：实体内部的联系、实体之间的联系 实体内部的联系 实体各属性之间的联系 实体之间的联系 通常指不同实体集之间的联系 &nbsp; 2、机器世界的术语 记录—record 字段的有序集合(实体) 文件—file 同一类记录或不同类记录集合(实体集) 关键码，主键，主码—key 能唯一标识文件中每条记录的字段或字段集（实体标识符） 字段—field 标记实体属性的命名单位，亦称数据项(属性) &nbsp; &nbsp;&nbsp; 3、实体集间的联系1 : 1 (一对一联系) 如观众与座位，病人与病床 1 : n (一对多联系) 如城市与街道，班级与学生 m : n (多对多联系) 如学生与课程，商店与顾客 &nbsp;&nbsp; 4、常用的概念模型——实体联系模型Entity relationship model，简称ER模型，是 由美籍华人陈平山于1976 年提出的。ER图提供了表示实体、 属性和联系的方法。 ER模型三要素（三个基本语义）A. 实体 (Entity)：表示客观事物。 B. 属性 (Attributes) ： 表示客观事物的特征（属性） C. 联系 (Relationships) ： 客观事物之间的联系 ER图表示方法 ER图示例： 业务场景（business scenario）：假设一个学生可选多门 课程，而一门课程又有多个学生选修，一个教师可讲多门 课程，一门课程至多只有一个教师讲授。 &nbsp;&nbsp; 拓展ER模型（Enhanced Entity Relationship Model）Enhanced ER Diagram Tutorial | Lucidchart &nbsp;&nbsp; 第三节课讲到PPT第80页，还没写完 mooc上的错题也要记录呀！！ &nbsp;&nbsp; &nbsp;&nbsp; 致谢感谢林友芳老师和助教们的辛勤付出。 感谢DXQ、CWB、LJY、LYS、GYC解答我的问题。","categories":[],"tags":[{"name":"class notes","slug":"class-notes","permalink":"http://glisses.github.io/tags/class-notes/"}]},{"title":"知识表示与处理课堂笔记","slug":"知识表示与处理课堂笔记","date":"2021-09-14T08:09:45.000Z","updated":"2021-09-21T07:18:44.790Z","comments":true,"path":"2021/09/14/知识表示与处理课堂笔记/","link":"","permalink":"http://glisses.github.io/2021/09/14/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"课程基本信息教师：周雪忠 个人主页：http://faculty.bjtu.edu.cn/8029/ 教材：无指定教材 &nbsp; 课程安排 课堂讲授 40学时 上机实验 24学时 &nbsp;","text":"课程基本信息教师：周雪忠 个人主页：http://faculty.bjtu.edu.cn/8029/ 教材：无指定教材 &nbsp; 课程安排 课堂讲授 40学时 上机实验 24学时 &nbsp; &nbsp; 分数构成 课程成绩构成及比例 考核环节 目标分值 提交时间 考核/评价细则 文献报告1(知识表示与推理方法前沿) 10 第3 周周日晚12:00 通过阅读最新文献，对新的知识表示与推理方法进行归纳和总结，主要考查学生对知识表示与处理概念、技术和方法等知识点的理解和掌握程度。 文献报告2(专家系统) 10 第5 周周日晚12:00 通过阅读学术论文，对近期发表的专家系统研究工作进行阐述和归纳，主要考查学生对专家系统概念、技术和方法等知识点的理解和掌握程度。 平时成绩60% 程序作业1(知识表示方法) 20 第9 周周日晚12:00 根据程序作业实验的实验运行情况和实验报告质量进行评分，考查学生对知识表示方法如语义网络等知识的理解及技术应用能力。 程序作业2(知识推理方法) 20 第13周周日晚12:00 根据程序作业实验的实验运行情况和实验报告质量进行评分，考查学生对知识推理方法的理解及技术应用能力。 程序作业3(知识图谱) 30 第15周周日晚12:00 根据程序作业实验的实验运行情况和实验报告质量进行评分，考查学生对知识图谱构建及处理方法的理解及技术应用能力。 平时表现(课堂互动等) 10 评估学生的学习积极性和AI思维能力。 期末考试40% 客观题 30 （1）卷面成绩100分，以卷面成绩的40%计入课程总评成绩。 闭卷 主观题 70 （2）主要考核知识工程基础知识，主要技术和方法如知识表示、知识推理、专家系统、知识图谱、研究前沿等内容。 &nbsp; 作业详细信息作业提交邮箱：kr_bjtu@163.com &nbsp; 文字作业1：知识表示与推理方法前沿练习目标：学会前沿英文文献检索与阅读，了解知识表示与推理前沿方法。 作业形式：8-10页的调研报告，Word或者PDF，学号_姓名_kr.docx/PDF。 作业完成内容： 题目：文献报告-文献原文的英文原文及中文翻译题目 中文摘要：以原文英文摘要为依据，采用自己的语言进行规范表达。 问题定义：采用自己的语言表达相关文献所解决的问题及形式化定义。 方法及原理：文献所提出方法的主要原理及形式化表达。 研究结果：文献中的主要实验结果（可剪切原文中的图表进行说明）。 创新点：以自己的语言及理解归纳文献所提方法的创新点。 阐述对文献研究相关问题及研究方向的个人体会。 文献出处：采用规范的文献引文格式给出所阅读的文献信息。 文献可以看麦卡锡等大佬的经典论文，或者近五年的顶会论文。看2-3篇。 提交时间：第3周周日晚12:00。 &nbsp; 文字作业2：专家系统作业练习目标：学会前沿英文文献检索与阅读，了解典型或者前沿的各类专家系统研究案例。 作业形式：8-10页的调研报告，Word或者PDF，学号_姓名_kr.docx/PDF。 作业完成内容： 题目：文献报告-文献原文的英文原文及中文翻译题目 中文摘要：以原文英文摘要为依据，采用自己的语言进行规范表达。 问题定义：采用自己的语言表达相关文献所解决的问题及形式化定义。 方法及原理：文献所提出方法的主要原理及形式化表达。 研究结果：文献中的主要实验结果（可剪切原文中的图表进行说明）。 创新点：以自己的语言及理解归纳文献所提方法的创新点。 阐述对文献研究相关问题及研究方向的个人体会。 文献出处：采用规范的文献引文格式给出所阅读的文献信息。 提交时间：第5周周日晚12:00。 &nbsp; 作业3（程序）：知识获取方法作业练习目标：以临床病历数据为来源，人机协同标注一定量标准数据集，研发基于机器学习的命名实体抽取等非结构化知识获取方法。 作业形式：提交代码及实验报告，实验报告以Word或者PDF形式。 实验报告内容： 题目：基于XXX模型的文本知识获取方法分析报告 研究背景：阐述所提命名实体抽取方法的必要性和价值 实验数据描述：对实验数据的特征、样本量等进行必要的描述（重点阐述标准数据集的信息） 模型及参数设置：阐述模型的原理、并对为何选择相应模型的理由进行阐述（说明该模型的优点） 实验结果：以图表及相应简要的文字说明阐述，模型预测的结果；以及相应的多种模型比较分析结果。 讨论及结论：对分析结果的新颖性、价值及存在的不足进行讨论，并明确获得的可靠结论。 参考文献：跟作业1的要求一致。 提交时间：教学第9周周日晚12:00。 &nbsp; 作业4（程序）：知识推理方法作业练习目标：阅读文献，实现任意一种知识推理算法，进行知识图谱补全处理，通过该实验，锻炼人工智能模型构建和研发能力。 作业形式：完成相应的程序代码及其测试结果，形成实验报告结果（以Word或者PDF进行书写）。 实验报告内容： 题目：基于XXX模型的知识补全方法分析报告 研究背景：阐述所提知识推理方法的必要性和价值 实验数据描述：对实验数据的特征、样本量等进行必要的描述（重点阐述标准知识图谱库的信息） 模型及参数设置：阐述模型的原理、并对为何选择相应模型的理由进行阐述（说明该模型的优点） 实验结果：以图表及相应简要的文字说明阐述，模型预测的结果；以及相应的多种模型比较分析结果。 讨论及结论：对分析结果的新颖性、价值及存在的不足进行讨论，并明确获得的可靠结论。 参考文献：跟作业1的要求一致。 提交时间：教学第13周周日晚12:00。 &nbsp; 作业5（程序）：知识图谱综合作业练习目标：综合以上作业4&amp;5的算法，通过集成外源性知识图谱数据，部署Neo4J等图数据库进行存储管理，并进行知识查询和推理应用，完成个性化知识图谱工程。 作业形式：完成相应的程序代码及其测试结果，形成实验报告结果（以Word或者PDF进行书写）。 实验报告内容： 题目：XXX知识图谱工程 研究背景：阐述领域知识图谱构建的价值和意义。 图谱数据来源：描述各类来源知识图谱的信息 技术与方法：阐述知识获取方法，知识推理方法、图数据存储和查询等方法 实验结果：对知识图谱进行展示和查询等操作，以图表及相应简要的文字说明阐述构建的知识图谱。 讨论及结论：对研发结果的新颖性、价值及存在的不足进行讨论，并明确获得的可靠结论。 参考文献：跟作业1的要求一致。 提交时间：教学第15周周日晚12:00。 &nbsp; 第0讲 绪论知识表示与处理技术是AI的两大支撑技术之一。 AI的两大支撑技术： 知识工程（知识表示与处理），演绎推理 机器学习（数据挖掘），归纳推理 &nbsp; 第1讲 知识表示与处理概述1.0 AI为什么需要知识表示与处理技术？机器学习存在很多局限： 医学人工智能：机器学习（特别是深度学习）很多是黑箱模型，可解释性差 Machine learning is frequently referred to as a black box—data goes in, decisions come out, but the processes between input and output are opaque. Particularly for neural networks,.. 无人驾驶：目前的无人驾驶系统等智能系统仍缺乏常识性知识 有感知智能但无因果推理等认知性智能 机器学习（归纳推理技术）存在泛化不足、鲁棒性差等诸多缺陷 科学的酒徒 在人工智能模型中，可能存在某些特征（汽水），帮助模型在标准数据集取得很好的性能，但实际上并没有因果关系。这是因为标准数据集与现实应用场景的数据分布非常不同，而非独立同分布。 &nbsp; 归纳法的本质：不是发现的通路，也不是证明的规则，而是检验假说的工具。 因此，可靠、可信和可解释性*的人工智能需要知识处理（对知识进行表示和推理）的技术和方法，以支持演绎性推理。 &nbsp; 1.1 知识工程基本概念与技术知识工程(Knowledge Engineering)专家系统之父、知识工程奠基人：费根鲍姆（要考） &nbsp; 知识(Knowledge) 柏拉图的经典定义：一条陈述能称得上是知识必须满足三个条件，它一定是被验证过的，正确的，而且是被人们相信的。 知识也是人类在实践中认识客观世界（包括人类自身）的成果，它包括事实、信息的描述或在教育和实践中获得的技能。 &nbsp; 知识库(Knowledge base) 专家系统设计所应用的规则集合，包含规则所联系的事实及数据，它们的全体构成知识库。 知识库相对于数据库而言，其中存储的是知识，而不是数据。 &nbsp; 专家系统(Expert system)专家系统之父、知识工程奠基人：费根鲍姆（要考） In artificial intelligence, an expert system is a computer system that emulates the decision-making ability of a human expert. 在人工智能领域，专家系统是一个模拟人类专家决策能力的计算机系统。 &nbsp; 知识表示(Knowledge representation)对知识的一种描述，或者说是对知识的一组约定，一种计算机可以接受的用于描述知识的数据结构。 知识表示方法: 约定了知识表示的一系列规则 逻辑表示法，如偶数的数学定义。 产生式表示法，又称规则表示法 框架(frame)表示法 面向对象的表示方法 语义网表示法 本体表示法 描述逻辑(description logics) &nbsp; 知识获取(Knowledge acquisition)现在：把问题求解的专门知识从专家头脑或者其他知识源（如书本、文献）中提取出来，并将之转换为计算机内部表示的过程。 &nbsp; 知识推理(Knowledge reasoning/inference)通常从已知的知识出发，通过一系列逻辑思考找出蕴含的知识或者事实，或者归纳出新的知识，这个过程称为推理。 &nbsp; 基于知识的系统(knowledge-based system, KBS) A knowledge-based system (KBS) is a computer program that reasons and uses a knowledge base to solve complex problems. 基于知识的系统（KBS）是一个计算机程序，它可以推理并使用知识库来解决复杂问题。 A knowledge based system has three types of sub-systems: a knowledge base, an user interface and an inference engine. 一个基于知识的系统有三种类型的子系统：知识库、用户界面和推理引擎。 Another advancement was the development of special purpose automated reasoning systems called classifiers. 另一个进步是开发了称为分类器的特殊用途自动推理系统。 第一节课到此结束 &nbsp; 1.2 知识工程的经典研究 Newell和Simon，两个人物。 &nbsp; MYCIN专家系统，好！ &nbsp;","categories":[],"tags":[{"name":"class notes","slug":"class-notes","permalink":"http://glisses.github.io/tags/class-notes/"}]},{"title":"机器学习课堂笔记","slug":"机器学习课堂笔记","date":"2021-09-09T05:47:59.000Z","updated":"2021-10-29T13:04:18.987Z","comments":true,"path":"2021/09/09/机器学习课堂笔记/","link":"","permalink":"http://glisses.github.io/2021/09/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"课程基本信息教师：景丽萍 办公室：九教北505 （ A ） 电子邮箱：lpjing@bjtu.edu.cn 个人主页：http://faculty.bjtu.edu.cn/8249/ 教材：西瓜书by周志华 分数构成 考勤和课堂 10% 上机实践8次（带电脑） 60% 大作业、代码及报告（10选2）演讲 30% 助教、答疑时间地点等见《本科机器学习-ch00-课程简介.pdf》第六页 ​ 课程安排：","text":"课程基本信息教师：景丽萍 办公室：九教北505 （ A ） 电子邮箱：lpjing@bjtu.edu.cn 个人主页：http://faculty.bjtu.edu.cn/8249/ 教材：西瓜书by周志华 分数构成 考勤和课堂 10% 上机实践8次（带电脑） 60% 大作业、代码及报告（10选2）演讲 30% 助教、答疑时间地点等见《本科机器学习-ch00-课程简介.pdf》第六页 ​ 课程安排： 第一节课到此结束 ​ 绪论人工智能与机器学习人工智能 &gt; 机器学习 &gt; 深度学习 ​ 机器学习定义机器学习粗略定义机器学习可以粗略地理解为：让机器根据数据，找到我们想要的一个函数的能力。 ​ 机器学习更广泛的定义 最常用定义 “计算机系统能够利用经验提高自身的性能” 可操作定义 “机器学习本质是一个基于经验数据的函数估计问题” 统计学定义 “提取重要模式、趋势，并理解数据， 即从数据中学习” 机器学习，从数据中自动地提取知识 ​ 机器学习主要框架如何找到我们想要的那个函数呢？三步走： 有多种scenario（方案）： supervised learning semi-supervised learning transfer learning unsupervised learning reinforcement learning structured learning ​ 回归问题与分类问题回归（regression） 注：scalar n.数量，标量。 上图中，f预测明天的PM2.5的值，这个值是连续的。预测一个数，是回归问题；预测一个等级，是分类问题。 ​ 分类（classification） 图像识别和AlphaGO也属于分类问题。图像识别中，每个物种是一个class；AlphaGO决定下一步棋该下在哪个位置，也是棋盘大小种class。 ​ 无监督学习生成模型（PixelRNN、VAE、GAN）属于无监督学习。但是它是如何保证生成图像的质量呢？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？我不知道啊！！！！！！！！！！！！！！ ​ 结构化学习structured learning：根据不同的输入，做不同的任务，给出不同的输出。 ​ 【自己的补充】 早期处理文本，是用新华字典等建立一个词库（桶），然后统计一个文档里出现了什么词，出现了几次（桶排）。即从无结构化数据，转化为有结构化数据。 ​ 强化学习难点在于怎么评价某个决策的好坏。 ​ 【自己的补充】 弱监督学习弱监督学习（weakly supervised learning）适用于：数据有噪声，有点用但是不能完全信任。 弱监督学习可以分为三种典型的类型： 不完全监督（Incomplete supervision） 不确切监督（Inexact supervision） 不精确监督（Inaccurate supervision） ​ 不完全监督是指，训练数据中只有一部分数据被给了标签，有一些数据是没有标签的。 应对方法1：主动学习（active learning），主动输出最有价值的未标记实例，让人工去标记。 应对方法2：半监督学习（semi-supervised learning） 不确切监督是指，训练数据只给出了粗粒度标签。我们可以把输入想象成一个包，这个包里面有一些示例，我们只知道这个包的标签，Y或N，但是我们不知道每个示例的标签。 应对方法：多实例学习（multi-instance learning） 不精确监督是指，给出的标签不总是正确的，比如本来应该是Y的标签被错误标记成了N。 应对方法：带噪学习（Learning with label noise）：删除或修改可疑点（可疑点是模型认为可能标错了的点） 这三种，在现实中常常一起出现。 ​ 【参考资料】： https://zhuanlan.zhihu.com/p/81404885 ​ 西瓜书补充基本术语 — 泛化能力机器学习的目标是使得学到的模型能很好的适用于“新样本”,而不仅仅是训练集合。我们称模型适用于新样本的能 力为泛化(generalization)能力。 通常假设样本空间中的样本服从一个未知分布𝒟，样本从这 个分布中独立获得，即“独立同分布”(i.i.d)（independently identical distribution）。一般而言训练样本越多越有可能通过学习获得强泛化能力的模型。 ​ 【自己的补充】 独立同分布独立同分布（iid，independently identically distribution） 这个假设非常理想，实际上，数据往往不满足iid。比如：不同属性之间并不独立，健康人的脉搏和体温都在正常范围。 ​ 归纳偏好 奥卡姆剃刀“奥卡姆剃刀”是一种常用的、自然科学研究中最基 本的原则，即“若有多个假设与观察一致，选最简单的那个”。 ​ 没有免费的午餐定理（No Free Lunch） 见西瓜书P8-9。可以证明： 对于二分类问题，所有可能f按均匀分布，则可以推出总误差与学习算法无关！也就是说，胡乱猜和很精确复杂的模型，它的误差期望是一样的。 但是！实际问题中，所有问题出现的可能性并不相同，不满足均匀分布。真正值得我们关注的，也只是其中的一小部分问题。脱离具体问题，空谈“什么算法更好”毫无意义。 ​ 统计学习、连接主义与符号主义符号主义学习 决策树：以信息论为基础，最小化信息熵，模拟了人类对概念进行判定的树形流程 基于逻辑的学习：使用一阶逻辑进行知识表示，通过修改扩充逻辑表达式对数据进行归纳 连接主义学习（基于神经网络） 1983年，J.J. Hopfield利用神经网络成功求解“流动推销员问题” 1986年，D.E. Rumelhart等人重新发明了著名的BP算法 深度学习：数据大，计算能力强 ​ 【一些自己的补充】 符号主义与连接主义 “符号主义”（Symbolicism），又称逻辑主义、计算机学派，主张用公理和逻辑体系搭建一套人工智能系统。 符号主义早期不是数据驱动的，它不需要训练，而是用大量的专家人力，去指定规则、公理等。现在的知识图谱，则会做知识蒸馏，应用了一些自适应的方法。这部分是数据驱动的。 “连接主义”（Connectionism），又叫仿生学派，主张模仿人类的神经元，用神经网络的连接机制实现人工智能。 ​ 统计学习 支持向量机（SVM）及核方法 ​ 【老师上课补充】 推荐算法推荐算法要考虑多样性推荐，人的爱好是多元的。这也是推荐算法的难点。要考虑不重复，学生上完机器学习，mooc就不该推荐机器学习课了。 第二节课到此结束 ​ SVM的kernel参数SVM的kernel参数中linear, poly, rbf, sigmoid 这几个参数都是什么意思呢？ linear线性核函数，是在数据线性可分的情况下使用的，运算速度快，效果好。不足在于它不能处理线性不可分的数据。 poly多项式核函数,多项式核函数可以将数据从低维空间映射到高维空间，但参数比较多，计算量大。 rbf（default）高斯核函数（默认）,高斯核函数同样可以将样本映射到高维空间，但相比于多项式核函数来说所需的参数比较少，通常性能不错，所以是默认使用的核函数。 sigmoidsigmoid 核函数,sigmoid 经常用在神经网络的映射中。因此当选用 sigmoid 核函数时，SVM 实现的是多层神经网络。 ​ 可以看出，在对同一个测试集进行分类时，采用不同的核函数会有不同的效果。且分界面的形状与核函数本身的形状相似。如应用sigmoid核函数时，显示明显的S形；应用rbf核函数时，显示等高线般的分界面。 ​ 对偶问题要理解对偶问题，先看拉格朗日乘子法 再看对偶问题 KKT的证明不会。","categories":[],"tags":[{"name":"class notes","slug":"class-notes","permalink":"http://glisses.github.io/tags/class-notes/"}]},{"title":"markdown常用语法","slug":"markdown常用语法","date":"2021-09-09T05:33:06.000Z","updated":"2021-09-21T14:27:26.986Z","comments":true,"path":"2021/09/09/markdown常用语法/","link":"","permalink":"http://glisses.github.io/2021/09/09/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"手写空格1&amp;nbsp; &nbsp; 字体颜色1 &lt;font color='red'&gt; text &lt;/font&gt; 效果： text 参考资料：https://blog.csdn.net/COCO56/article/details/105155328 &nbsp; 插入图片并调整大小普通的插入图片：1![教材](https://raw.githubusercontent.com/glisses/ImageWarehouse/main/img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-1.png) &nbsp; 插入图片并按比例缩放1&lt;img src=\"https://raw.githubusercontent.com/glisses/ImageWarehouse/main/img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-1.png\" alt=\"教材\" style=\"zoom:150%;\" /&gt;","text":"手写空格1&amp;nbsp; &nbsp; 字体颜色1 &lt;font color='red'&gt; text &lt;/font&gt; 效果： text 参考资料：https://blog.csdn.net/COCO56/article/details/105155328 &nbsp; 插入图片并调整大小普通的插入图片：1![教材](https://raw.githubusercontent.com/glisses/ImageWarehouse/main/img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-1.png) &nbsp; 插入图片并按比例缩放1&lt;img src=\"https://raw.githubusercontent.com/glisses/ImageWarehouse/main/img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-1.png\" alt=\"教材\" style=\"zoom:150%;\" /&gt; &nbsp; 插入图片并指定长宽和对齐1&lt;img src=\"https://raw.githubusercontent.com/glisses/ImageWarehouse/main/img/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0-1.png\" width = \"500\" height = \"600\" alt=\"图片名称\" align=left&gt; align= 描述 left 左对齐内容。 right 右对齐内容。 center 居中对齐内容。 justify 对行进行伸展，这样每行都可以有相等的长度（就像在报纸和杂志中）。","categories":[],"tags":[{"name":"md","slug":"md","permalink":"http://glisses.github.io/tags/md/"}]},{"title":"数字图像处理课堂笔记","slug":"数字图像处理课堂笔记","date":"2021-09-09T01:41:23.000Z","updated":"2021-09-09T05:37:08.180Z","comments":true,"path":"2021/09/09/数字图像处理课堂笔记/","link":"","permalink":"http://glisses.github.io/2021/09/09/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/","excerpt":"课程基本信息教师：安高云 教材：红皮数字图像处理学 阮秋绮 第三版 平时作业40%，期末考60%。 在12周结束授课，13-15周做实验。","text":"课程基本信息教师：安高云 教材：红皮数字图像处理学 阮秋绮 第三版 平时作业40%，期末考60%。 在12周结束授课，13-15周做实验。 第二个实验：用纯C/C++写图像处理 ​ 绪论（不考）图像是人们从客观世界获取信息的重要来源：人类是通过感觉器官从客观世界获取信息，即通过耳、目、口、鼻、手通过听、看、味、嗅和触摸的方式获取信息。在这些信息中，视觉信息占60％～70％。 ​ 图像处理技术的分类​ 模拟图像处理(Analog image processing)模拟处理包括：光学处理（利用透镜）和电子处理，如：照相、遥感图像处理、传统电视信号处理等，传统电视图像是模拟信号处理的典型例子，它处理的是活动图像，25帧/秒。 优点：模拟图像处理的特点是速度快，一般为实时处理，理论上讲可达到光的速度，并可同时并行处理。 缺点：模拟图像处理的缺点是精度较差，灵活性差，很难有判断能力和非线性处理能力 ​ 数字图像处理(Digital Image processing)：数字图像处理一般都用计算机处理，因此也称之谓计算机图像处理（ Computer Image Processing）。 优点：处理精度高，处理内容丰富，可进行复杂的非线性处理，有灵活的变通能力，一般来说只要改变软件就可以改变处理内容。 缺点： 处理速度还是一个问题，特别是进行复杂的处 理更是如此。一般情况下处理静止画面居多， 如果实时处理一般精度的数字图像需要具有 100Mips的处理能力； 其次是分辨率及精度尚有一定限制，如一般精度 图像是512×512×8bits，分辨率高的可 2048×2048×12bits，如精度及分辨率再高，所 需处理时间将显著增加。 ​ 数字图像处理的特点 图像信息量大、数据量也大； 图像处理技术综合性强； 图像信息理论与通信理论密切相关。 ​ 数字图像处理的主要方法和主要内容主要方法分为两大类：空域法和变换域法 空域法把图片看成一个个像素点，当作二维数组来处理。主要包括两大类： 邻域处理法： 梯度运算 (gradient Algorithm) 拉普拉斯算子运算 (Laplacian operator) 平滑算子运算 (Smoothing operator) 卷积运算 (Convolution algorithm) 点处理法： 灰度处理（grey processing） 面积、周长、体积、重心运算等等 变换域法（不会）数字图像处理的变换域处理方法是首先对图 像进行正交变换，得到变换域系数阵列，然后 再施行各种处理，处理后再反变换到空间域， 得到处理结果。 这类处理包括：滤波、数据压缩、特征提取 等处理。 ​ 一些应用三维重建、图像复原、图像增强等。 ​ 第一节课到此结束","categories":[],"tags":[{"name":"class notes","slug":"class-notes","permalink":"http://glisses.github.io/tags/class-notes/"}]},{"title":"numpy常用命令","slug":"numpy常用命令","date":"2021-08-30T10:12:41.000Z","updated":"2021-09-08T03:41:31.602Z","comments":true,"path":"2021/08/30/numpy常用命令/","link":"","permalink":"http://glisses.github.io/2021/08/30/numpy%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"什么是numpyNumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C/C++/Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能","text":"什么是numpyNumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。 NumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含： 一个强大的N维数组对象 ndarray 广播功能函数 整合 C/C++/Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能 求最大值np.max及其索引np.argmax由于我太菜了这里只介绍一维数组用法。 12one_dim_array = np.array([1, 4, 5, 3, 7, 2, 6])print(np.argmax(one_dim_array), np.max(one_dim_array)) 14 7 生成全零数组np.zeros12vis = np.zeros((512,512), dtype = bool)blo = np.zeros((512,512), dtype = int) dtype可以指定类型。blo如果不指定类型，可能会是[[0.,0.,0.,……]] ​ 矩阵二值化np.where我正在寻找一种基于阈值仅使用一个表达式来对numpy N-d数组进行二值化的方法。 1234np.random.seed(0)np.set_printoptions(precision=3)a = np.random.rand(4, 4)threshold, upper, lower = 0.5, 1, 0 a现在是： 1234array([[ 0.02 , 0.833, 0.778, 0.87 ], [ 0.979, 0.799, 0.461, 0.781], [ 0.118, 0.64 , 0.143, 0.945], [ 0.522, 0.415, 0.265, 0.774]]) 现在我可以触发这两个表达式： 12a[a&gt;threshold] = uppera[a&lt;=threshold] = lower 实现我的目标： 1234array([[ 0., 1., 1., 1.], [ 1., 1., 0., 1.], [ 0., 1., 0., 1.], [ 1., 0., 0., 1.]]) 但有没有办法只用一个表达式来做到这一点？ 有的！ 123456np.where(a&gt;threshold, upper, lower)Out[6]: array([[0, 1, 1, 1], [1, 1, 0, 1], [0, 1, 0, 1], [1, 0, 0, 1]])","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"各个系统下ping IP+端口的方法","slug":"各个系统下ping-IP-端口的方法","date":"2021-08-12T04:03:22.000Z","updated":"2021-08-12T04:25:04.070Z","comments":true,"path":"2021/08/12/各个系统下ping-IP-端口的方法/","link":"","permalink":"http://glisses.github.io/2021/08/12/%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B8%8Bping-IP-%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"前言做开发的人员，可能都会遇到网络的一些问题。这时一般都需要测试指定的网络是否能正常访问。通常在windows系统下，在cmd里直接用命令ping指定的IP或者域名就可以快速的知道这个地址是否是可以访问通不通的。 但是如果一个服务器上启动着好几个项目，通过指定不同的端口来区分。想要知道其中某个端口的系统是否可以访问通，一般的ping命令是解决不了这个问题的，因为不管在windows下还是linux下，ping命令只能跟IP地址或者域名，是不能加端口访问的。这时我们就可以借助一些工具，来帮助我们达成目的。 ​ Windows下的方法在windows下，我们可以下载tcping这个小工具来帮助我们查看指定的端口是否是通的。","text":"前言做开发的人员，可能都会遇到网络的一些问题。这时一般都需要测试指定的网络是否能正常访问。通常在windows系统下，在cmd里直接用命令ping指定的IP或者域名就可以快速的知道这个地址是否是可以访问通不通的。 但是如果一个服务器上启动着好几个项目，通过指定不同的端口来区分。想要知道其中某个端口的系统是否可以访问通，一般的ping命令是解决不了这个问题的，因为不管在windows下还是linux下，ping命令只能跟IP地址或者域名，是不能加端口访问的。这时我们就可以借助一些工具，来帮助我们达成目的。 ​ Windows下的方法在windows下，我们可以下载tcping这个小工具来帮助我们查看指定的端口是否是通的。 https://elifulkerson.com/projects/tcping.php （下载地址） 进去后，直接下载tcping.exe 那个文件就行。然后把下载好的工具放到电脑的C盘&gt;Windows&gt;System32 下面就行。 然后我们直接重新打开CMD窗口，输入命令：tcping 指定的IP或者域名 端口号 。输入完回车就可以查看这个IP的端口是否是通着的。 比如： 1tcping 10.20.66.37 8090 ​ Linux下的方法在linux下，我们就直接可以用telnet命令来测试端口是否畅通。具体用法：telnet 指定的IP或者 域名 端口号. 比如： 1telnet 10.20.66.37 8090 ​ 最后测试端口是否连通的方法当然不止这些，还有许多其他的方法，小编这里是说了这几种都是常用简单的方法。希望能够帮到大家，谢谢。 ————————————————版权声明：本文为CSDN博主「SimpleSmile_5177」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_37751990/article/details/82286912","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"常用linux命令","slug":"常用linux命令","date":"2021-08-12T03:37:14.000Z","updated":"2021-08-24T07:04:37.276Z","comments":true,"path":"2021/08/12/常用linux命令/","link":"","permalink":"http://glisses.github.io/2021/08/12/%E5%B8%B8%E7%94%A8linux%E5%91%BD%E4%BB%A4/","excerpt":"pwd获得当前路径1pwd Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。 执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。 ​ clear清屏1clear clear命令将会刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。一般都会用这个命令。 备注：在windows的终端里，清屏用cls。","text":"pwd获得当前路径1pwd Linux pwd（英文全拼：print work directory） 命令用于显示工作目录。 执行 pwd 指令可立刻得知您目前所在的工作目录的绝对路径名称。 ​ clear清屏1clear clear命令将会刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。一般都会用这个命令。 备注：在windows的终端里，清屏用cls。 find查找文件Linux中在当前目录及其子目录下查找某个文件可以使用find命令。 1、比如在/usr/lib下查找klibc的文件，进入/usr/lib目录后，可以执行 1find . -name \"klibc\" 说明:find命令用于查找文件，后面的“.”代表当前目录，-name是find命令的参数，后面接要搜索的文件名。 2、如果不明确文件名称，可以使用通配符 ​ 1find . -name \"*libc*\" 参数说明find用法：find 要查找的路径 参数-name参数：指定要查找的文件名-user参数：指定要查找的文件所属用户-type参数指定查找文件的类型，分别有d目录、l连接文件、s socket文件等 dir将所有/指定文件的名称输出到文档 将某文件夹及其子文件夹内的所有文件的文件名输出到指定文件 1dir /s/b &gt; 所有文件.txt 输出示例： 将某文件夹及其子文件夹内的指定类型文件(如cpp文件)的文件名输出到指定文件 1dir /s/b *.cpp &gt; 所有文件.txt ​","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"Python调试新利器pdb++","slug":"Python调试新利器pdb","date":"2021-08-10T06:18:24.000Z","updated":"2021-08-10T06:59:12.632Z","comments":true,"path":"2021/08/10/Python调试新利器pdb/","link":"","permalink":"http://glisses.github.io/2021/08/10/Python%E8%B0%83%E8%AF%95%E6%96%B0%E5%88%A9%E5%99%A8pdb/","excerpt":"​ 什么是pdb++pdb++是pdb标准库的拓展，它能完全兼容pdb，连之前的代码都不需要修改。 pdb++也是用于python调试的好工具，使用起来非常方便，就在想设置断点的地方加一行pdb.set_trace()即可。 ​ 安装pdb++由于pdb++不是合法的package name，该包被命名为pdbpp。 用pip安装： 1$ pip install pdbpp 用conda安装： 1$ conda install -c conda-forge pdbpp 当然，你也可以把pdb.py放到自己的pythonpath里。 ​ pdb++的使用使用pdb++和使用pdb一样，就是：","text":"​ 什么是pdb++pdb++是pdb标准库的拓展，它能完全兼容pdb，连之前的代码都不需要修改。 pdb++也是用于python调试的好工具，使用起来非常方便，就在想设置断点的地方加一行pdb.set_trace()即可。 ​ 安装pdb++由于pdb++不是合法的package name，该包被命名为pdbpp。 用pip安装： 1$ pip install pdbpp 用conda安装： 1$ conda install -c conda-forge pdbpp 当然，你也可以把pdb.py放到自己的pythonpath里。 ​ pdb++的使用使用pdb++和使用pdb一样，就是： 1234567import pdb...pdb.set_trace()... ​ 请注意，该模块名为 pdb.py，因此 pdb++ 将自动用于所有导入 pdb 的地方（例如 pytest –pdb 会给你一个 pdb++ 提示）。 旧的 pdb 模块仍然可以通过执行，例如： 1234567import pdb...pdb.pdb.set_trace()... ​ pdb++的常用指令兼容了pdb的常用指令。 根据网络资料整理的常用的PDB命令 进入Debug模式123- 命令行： 进入命令行Debug模式，python -m pdb xxx.py- sublime : Tools--&gt;SublimeREPL--&gt;python pdb- jupyter: 使用魔法命令：%%debug ipdb1python -m ipdb xxx.py ​ 辅助命令 h：（help）帮助 ​ 运行启动退出 run：重新启动debug，相当于restart q：（quit）退出debugexit() 也可以 代码执行 s：（step）执行下一条命令 如果本句是函数调用，则s会执行到函数的第一句 n：（next）执行下一条语句 如果本句是函数调用，则执行函数，接着执行当前执行语句的下一条。 r：（return）执行当前运行函数到结束 c：（continue）继续执行，直到遇到下一条断点 j ：（jump）设置下条执行的语句函数 只能在堆栈的最底层跳转，向后重新执行，向前可直接执行到行号 unt：（until）执行到下一行（跳出循环），或者当前堆栈结束 d：（down）执行跳转到在当前堆栈的深一层（个人没觉得有什么用处） u：（up）执行跳转到当前堆栈的上一层 断点 b：（break）添加断点 1234567b 列出当前所有断点，和断点执行到统计次数b line_no：当前脚本的line_no行添加断点b filename:line_no：脚本filename的line_no行添加断点b function：在函数function的第一条可执行语句处添加断点 tbreak：（temporary break）临时断点 在第一次执行到这个断点之后，就自动删除这个断点，用法和b一样 cl：（clear）清除断点 123456789101112131415161718192021222324252627282930 cl 清除所有断点 cl bpnumber1 bpnumber2... 清除断点号为bpnumber1,bpnumber2...的断点 cl lineno 清除当前脚本lineno行的断点 cl filename:line_no 清除脚本filename的line_no行的断点- disable：停用断点，参数为bpnumber，和cl的区别是，断点依然存在，只是不启用- enable：激活断点，参数为bpnumber- condition bpnumber conditon，给断点设置条件，当参数condition返回True的时候bpnumber断点有效，否则bpnumber断点无效### 打印查看- 输入变量名：查看变量值- w：（where）打印当前执行堆栈- l：（list）列出源码```python l 列出当前执行语句周围11条代码 l first 列出first行周围11条代码 l first second 列出first--second范围的代码，如果second&lt;first，second将被解析为行数 a：（args）列出当前执行函数的参数 p expression：（print）输出expression的值 pp expression：好看一点的p expression————————————————版权声明：本文为CSDN博主「sunpro518」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/sunjinshengli/article/details/104155455 pdb++的优势智能命令解析使用pdb的时候，如果你有个变量c，想看它的值，那么pdb就会显得很笨。它会优先把这个c识别为continue，而不是你的变量。 pdb++则解决了这个问题，它始终将你的指令优先翻译成域内的变量（如果存在）。当然，在你想使用continue等指令时，也可以加上两个！！来实现。例如： 123456789(Pdb++) list 1 2 def fn(): 3 c = 42 4 import pdb;pdb.set_trace() 5 -&gt; return c(Pdb++) c42(Pdb++) !!c ​ 其他优势详见github地址：https://github.com/pdbpp/pdbpp ​ ​ ​ 参考链接 https://www.cnblogs.com/c-x-a/p/10674288.html https://blog.csdn.net/sunjinshengli/article/details/104155455 https://github.com/pdbpp/pdbpp","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"终端复用器Tmux","slug":"终端复用器Tmux","date":"2021-08-05T03:37:58.000Z","updated":"2021-08-10T06:19:12.101Z","comments":true,"path":"2021/08/05/终端复用器Tmux/","link":"","permalink":"http://glisses.github.io/2021/08/05/%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8%E5%99%A8Tmux/","excerpt":"Tmux 使用教程本文全部转载自https://www.ruanyifeng.com/blog/2019/10/tmux.html 作者： 阮一峰 日期： 2019年10月21日 Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。 本文介绍如何使用 Tmux。","text":"Tmux 使用教程本文全部转载自https://www.ruanyifeng.com/blog/2019/10/tmux.html 作者： 阮一峰 日期： 2019年10月21日 Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。 本文介绍如何使用 Tmux。 一、Tmux 是什么？1.1 会话与进程命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。 1.2 Tmux 的作用Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。 （1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 （2） 它可以让新窗口”接入”已经存在的会话。 （3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 （4）它还支持窗口任意的垂直和水平拆分。 类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。 二、基本用法2.1 安装Tmux 一般需要自己安装。 12345678# Ubuntu 或 Debian$ sudo apt-get install tmux# CentOS 或 Fedora$ sudo yum install tmux# Mac$ brew install tmux 2.2 启动与退出安装完成后，键入tmux命令，就进入了 Tmux 窗口。 1$ tmux 上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。 按下Ctrl+d或者显式输入exit命令，就可以退出 Tmux 窗口。 1$ exit 2.3 前缀键Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。 举例来说，帮助命令的快捷键是Ctrl+b ?。它的用法是，在 Tmux 窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息。 然后，按下 ESC 键或q键，就可以退出帮助。 三、会话管理3.1 新建会话第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。 使用编号区分会话，不太直观，更好的方法是为会话起名。 1$ tmux new -s &lt;session-name&gt; 上面命令新建一个指定名称的会话。 3.2 分离会话在 Tmux 窗口中，按下Ctrl+b d或者输入tmux detach命令，就会将当前会话与窗口分离。 1$ tmux detach 上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。 tmux ls命令可以查看当前所有的 Tmux 会话。 123$ tmux ls# or$ tmux list-session 3.3 接入会话tmux attach命令用于重新接入某个已存在的会话。 12345# 使用会话编号$ tmux attach -t 0# 使用会话名称$ tmux attach -t &lt;session-name&gt; 3.4 杀死会话tmux kill-session命令用于杀死某个会话。 12345# 使用会话编号$ tmux kill-session -t 0# 使用会话名称$ tmux kill-session -t &lt;session-name&gt; 3.5 切换会话tmux switch命令用于切换会话。 12345# 使用会话编号$ tmux switch -t 0# 使用会话名称$ tmux switch -t &lt;session-name&gt; 3.6 重命名会话tmux rename-session命令用于重命名会话。 1$ tmux rename-session -t 0 &lt;new-name&gt; 上面命令将0号会话重命名。 3.7 会话快捷键下面是一些会话相关的快捷键。 Ctrl+b d：分离当前会话。 Ctrl+b s：列出所有会话。 Ctrl+b $：重命名当前会话。 四、最简操作流程综上所述，以下是 Tmux 的最简操作流程。 新建会话tmux new -s my_session。 在 Tmux 窗口运行所需的程序。 按下快捷键Ctrl+b d将会话分离。 下次使用时，重新连接到会话tmux attach-session -t my_session。 五、窗格操作Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。 5.1 划分窗格tmux split-window命令用来划分窗格。 12345# 划分上下两个窗格$ tmux split-window# 划分左右两个窗格$ tmux split-window -h 5.2 移动光标tmux select-pane命令用来移动光标位置。 1234567891011# 光标切换到上方窗格$ tmux select-pane -U# 光标切换到下方窗格$ tmux select-pane -D# 光标切换到左边窗格$ tmux select-pane -L# 光标切换到右边窗格$ tmux select-pane -R 5.3 交换窗格位置tmux swap-pane命令用来交换窗格位置。 12345# 当前窗格上移$ tmux swap-pane -U# 当前窗格下移$ tmux swap-pane -D 5.4 窗格快捷键下面是一些窗格操作的快捷键。 Ctrl+b %：划分左右两个窗格。 Ctrl+b &quot;：划分上下两个窗格。 Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。 Ctrl+b ;：光标切换到上一个窗格。 Ctrl+b o：光标切换到下一个窗格。 Ctrl+b {：当前窗格与上一个窗格交换位置。 Ctrl+b }：当前窗格与下一个窗格交换位置。 Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。 Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。 Ctrl+b x：关闭当前窗格。 Ctrl+b !：将当前窗格拆分为一个独立窗口。 Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。 Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。 Ctrl+b q：显示窗格编号。 六、窗口管理除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。 6.1 新建窗口tmux new-window命令用来创建新窗口。 1234$ tmux new-window# 新建一个指定名称的窗口$ tmux new-window -n &lt;window-name&gt; 6.2 切换窗口tmux select-window命令用来切换窗口。 12345# 切换到指定编号的窗口$ tmux select-window -t &lt;window-number&gt;# 切换到指定名称的窗口$ tmux select-window -t &lt;window-name&gt; 6.3 重命名窗口tmux rename-window命令用于为当前窗口起名（或重命名）。 1$ tmux rename-window &lt;new-name&gt; 6.4 窗口快捷键下面是一些窗口操作的快捷键。 Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。 Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。 Ctrl+b n：切换到下一个窗口。 Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。 Ctrl+b w：从列表中选择窗口。 Ctrl+b ,：窗口重命名。 七、其他命令下面是一些其他命令。 1234567891011# 列出所有快捷键，及其对应的 Tmux 命令$ tmux list-keys# 列出所有 Tmux 命令及其参数$ tmux list-commands# 列出当前所有 Tmux 会话的信息$ tmux info# 重新加载当前的 Tmux 配置$ tmux source-file ~/.tmux.conf 八、参考链接 A Quick and Easy Guide to tmux Tactical tmux: The 10 Most Important Commands Getting started with Tmux （完） 文档信息 版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证） 发表日期： 2019年10月21日 相关文章 2021.05.10: 软件工程的最大难题 一、引言 大学有一门课程《软件工程》，研究如何组织和管理软件项目。 2020.12.13: 《SSH 入门教程》发布了 SSH 是登录 Linux 服务器的必备工具，只要你在做互联网开发，多多少少都会用到它。 2020.11.02: 微信小程序入门教程之四：API 使用 今天是这个系列教程的最后一篇。 2020.10.29: 微信小程序入门教程之三：脚本编程 这个系列教程的前两篇，介绍了小程序的项目结构和页面样式。","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"计算机综合训练-基于Qt的数独小游戏","slug":"计算机综合训练-基于Qt的数独小游戏","date":"2021-07-21T09:06:18.000Z","updated":"2021-08-05T06:15:50.706Z","comments":true,"path":"2021/07/21/计算机综合训练-基于Qt的数独小游戏/","link":"","permalink":"http://glisses.github.io/2021/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83-%E5%9F%BA%E4%BA%8EQt%E7%9A%84%E6%95%B0%E7%8B%AC%E5%B0%8F%E6%B8%B8%E6%88%8F/","excerpt":"","text":"前言：计算机综合训练是博主在2021.7.19至2021.7.25的大二升大三暑假的小学期课程。这篇博客记录了小学期里我学到的知识。 这门课有两个任务：①读remill源码 ②写个可以玩的数独软件。本文只涉及第二部分。 Signal / Slot​ 信号和槽机制是 QT 的核心机制，要精通 QT 编程就必须对信号(Signal)和槽(Slot)有所了解。信号和槽是一种高级接口，应用于对象之间的通信，它是 QT 的核心特性，也是 QT 区别于其它工具包的重要地方。信号和槽是 QT 自行定义的一种通信机制，它独立于标准的 C/C++ 语言，因此要正确的处理信号和槽，必须借助一个称为 moc（Meta Object Compiler）的 QT 工具，该工具是一个 C++ 预处理程序，它为高层次的事件处理自动生成所需要的附加代码。 在我们所熟知的很多 GUI 工具包中，窗口小部件 (widget) 都有一个回调函数用于响应它们能触发的每个动作，这个回调函数通常是一个指向某个函数的指针。但是，在 QT 中信号和槽取代了这些凌乱的函数指针，使得我们编写这些通信程序更为简洁明了。 信号和槽能携带任意数量和任意类型的参数，他们是类型完全安全的，不会像回调函数那样产生 core dumps。 ​ 所有从 QObject 或其子类 ( 例如 Qwidget) 派生的类都能够包含信号和槽。当对象改变其状态时，信号就由该对象发射 (emit) 出去，这就是对象所要做的全部事情，它不知道另一端是谁在接收这个信号。这就是真正的信息封装，它确保对象被当作一个真正的软件组件来使用。槽用于接收信号，但它们是普通的对象成员函数。一个槽并不知道是否有任何信号与自己相连接。而且，对象并不了解具体的通信机制。 你可以将很多信号与单个的槽进行连接，也可以将单个的信号与很多的槽进行连接，甚至于将一个信号与另外一个信号相连接也是可能的，这时无论第一个信号什么时候发射系统都将立刻发射第二个信号。总之，信号与槽构造了一个强大的部件编程机制。 ​ 参考链接：https://blog.csdn.net/wellto/article/details/11773635","categories":[],"tags":[{"name":"大学专业课","slug":"大学专业课","permalink":"http://glisses.github.io/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"计算机综合训练","slug":"计算机综合训练","date":"2021-07-19T06:47:50.000Z","updated":"2021-07-21T08:41:00.004Z","comments":true,"path":"2021/07/19/计算机综合训练/","link":"","permalink":"http://glisses.github.io/2021/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%BC%E5%90%88%E8%AE%AD%E7%BB%83/","excerpt":"前言：计算机综合训练是博主在2021.7.19至2021.7.25的大二升大三暑假的小学期课程。这篇博客记录了小学期里我学到的知识。 这门课有两个任务：①读remill源码 ②写个可以玩的数独软件。 ​ cmd命令 将某文件夹及其子文件夹内的所有文件的文件名输出到指定文件 1dir /s/b &gt; 所有文件.cpp 输出示例： 将某文件夹及其子文件夹内的指定类型文件(如cpp文件)的文件名输出到指定文件 1dir /s/b *.cpp &gt; 所有文件.cpp ​ cmake语法​ set​ set有三个功能：设置普通变量、设置缓存入口、设置环境变量","text":"前言：计算机综合训练是博主在2021.7.19至2021.7.25的大二升大三暑假的小学期课程。这篇博客记录了小学期里我学到的知识。 这门课有两个任务：①读remill源码 ②写个可以玩的数独软件。 ​ cmd命令 将某文件夹及其子文件夹内的所有文件的文件名输出到指定文件 1dir /s/b &gt; 所有文件.cpp 输出示例： 将某文件夹及其子文件夹内的指定类型文件(如cpp文件)的文件名输出到指定文件 1dir /s/b *.cpp &gt; 所有文件.cpp ​ cmake语法​ set​ set有三个功能：设置普通变量、设置缓存入口、设置环境变量 ​ 详细可查看官方文档：https://cmake.org/cmake/help/latest/command/set.html 设置普通变量1set(&lt;variable&gt; &lt;value&gt;... [PARENT_SCOPE]) ​ &lt;variable&gt;在当前函数或目录范围内设置给定。 ​ 如果PARENT_SCOPE给出该选项，则变量将设置在当前范围之上的范围内。每个新目录或函数都会创建一个新作用域。此命令会将变量的值设置到父目录或调用函数中（以适用于手头的情况为准）。变量值的先前状态在当前作用域中保持不变（例如，如果之前未定义，则仍为未定义；如果有值，则仍为该值）。 ​ 设置缓存入口1set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]) ​ 设置给定的缓存&lt;variable&gt;（缓存条目）。由于缓存条目旨在提供用户可设置的值，因此默认情况下不会覆盖现有的缓存条目。使用该FORCE选项覆盖现有条目。 ​ &lt;type&gt;必须被指定为之一： BOOL 布尔ON/OFF值。 cmake-gui(1) 提供一个复选框。 FILEPATH 磁盘上文件的路径。 cmake-gui(1) 提供一个文件对话框。 PATH 磁盘上目录的路径。 cmake-gui(1) 提供一个文件对话框。 STRING 一行文字。 cmake-gui(1) 提供文本字段或下拉选择，如果 STRINGS 缓存条目属性已设置。 INTERNAL 一行文字。 cmake-gui(1)不显示内部条目。它们可用于跨运行持久存储变量。使用这种类型意味着FORCE. ​ ​ 将&lt;docstring&gt;必须被指定为提供的选项，以快速摘要呈现一行文本cmake-gui(1) 用户。 ​ 如果在调用之前缓存条目不存在或FORCE 给出了选项，则缓存条目将设置为给定值。 ​ 缓存条目可能在调用之前存在，但如果它是在调用之前创建的，则没有设置类型 cmake(1)命令行由用户通过-D&lt;var&gt;=&lt;value&gt;选项而不指定类型。在这种情况下，该set命令将添加类型。此外，如果命令行中提供的&lt;type&gt;isPATH或FILEPATH and&lt;value&gt;是相对路径，则该set命令会将路径视为相对于当前工作目录并将其转换为绝对路径。 ​ 设置环境变量1set(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;]) ​ 设置一个 Environment Variable 到给定的值。的后续调用$ENV{&lt;variable&gt;}将返回此新值。 ​ 此命令仅影响当前 CMake 进程，而不影响调用 CMake 的进程，也不会影响整个系统环境，也不会影响后续构建或测试过程的环境。 ​ 如果之后没有给出参数ENV{&lt;variable&gt;}或者 if&lt;value&gt;是空字符串，则此命令将清除环境变量的任何现有值。 ​ 后面&lt;value&gt;的参数被忽略。如果发现额外的参数，则会发出警告。 ​ 用法举例 set(libs “${CMAKE_SOURCE_DIR}/src/main/jnilibs”) ​ 这个命令完成了这么一件事情：定义了一个变量libs，并且变量的值为${CMAKE_SOURCE_DIR}/src/main/jnilibs，其中CMAKE_SOURCE_DIR 是一个cmake内置变量，指定了CMakeLists.txt所在的目录。详细介绍可参考：http://www.cnblogs.com/xianghang123/p/3556425.html。 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI})这个命令用于给CMAKE_LIBRARY_OUTPUT_DIRECTORY宏赋值，该宏指定了cmake编译输出的东西应该放在什么地方。 这个例子中的地方是${PROJECT_SOURCE_DIR}/src/main/jnilibs/${ANDROID_ABI} 其中PROJECT_SOURCE_DIR 是cmake内置宏，指向构建工程的全路径。详细介绍可参考https://www.cnblogs.com/alphagl/p/6280061.html————————————————参考链接：https://blog.csdn.net/guanguanboy/article/details/84838920 ​ list12345678910list(LENGTH &lt;list&gt;&lt;output variable&gt;)list(GET &lt;list&gt; &lt;elementindex&gt; [&lt;element index&gt; ...]&lt;output variable&gt;)list(APPEND &lt;list&gt;&lt;element&gt; [&lt;element&gt; ...])list(FIND &lt;list&gt; &lt;value&gt;&lt;output variable&gt;)list(INSERT &lt;list&gt;&lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])list(REMOVE_ITEM &lt;list&gt; &lt;value&gt;[&lt;value&gt; ...])list(REMOVE_AT &lt;list&gt;&lt;index&gt; [&lt;index&gt; ...])list(REMOVE_DUPLICATES &lt;list&gt;)list(REVERSE &lt;list&gt;)list(SORT &lt;list&gt;) LENGTH 返回list的长度 GET 返回list中index的element到value中 APPEND 添加新element到list中 FIND 返回list中element的index，没有找到返回-1 INSERT 将新element插入到list中index的位置 REMOVE_ITEM 从list中删除某个element REMOVE_AT 从list中删除指定index的element REMOVE_DUPLICATES 从list中删除重复的element REVERSE 将list的内容反转 SORT 将list按字母顺序排序 ———————————————— 参考链接：https://blog.csdn.net/yjjy0921/article/details/50378567 ​ find_package1234find_package(&lt;package&gt; [version] [EXACT] [QUIET] [MODULE] [REQUIRED] [[COMPONENTS] [components...]] [OPTIONAL_COMPONENTS components...] [NO_POLICY_SCOPE]) ​ 从外部项目中查找和加载设置。 &lt;package&gt;_FOUND 将设置为指示是否找到了包。当找到包时，包特定的信息通过包本身记录的变量和导入目标提供。QUIET如果找不到包，该 选项将禁用消息。该 MODULE选项禁用下面记录的第二个签名。REQUIRED如果找不到包，该 选项将停止处理并显示错误消息。详见官方文档 https://cmake.org/cmake/help/v3.0/command/find_package.htm ​ 但这个搜索包的过程是如何实现的呢？官方文档没有说明。 ​ 根据https://github.com/BrightXiaoHan/CMakeTutorial/tree/master/FindPackage 的指导，我梳理出下面的流程图。 ​ 通过Cmake内置模块引入依赖包​ CMake官方为我们预定义了许多寻找依赖包的Module，他们存储在path_to_your_cmake/share/cmake-&lt;version&gt;/Modules目录下。每个以Find.cmake命名的文件都可以帮我们找到一个包。我们也可以在官方文档中查看到哪些库官方已经为我们定义好了，我们可以直接使用find_package函数进行引用。 ​ 我们以curl库为例，假设我们项目需要引入这个库，从网站中请求网页到本地，我们看到官方已经定义好了FindCURL.cmake。所以我们在CMakeLists.txt中可以直接用find_pakcage进行引用。 12345678find_package(CURL)add_executable(curltest curltest.cc)if(CURL_FOUND) target_include_directories(clib PRIVATE $&#123;CURL_INCLUDE_DIR&#125;) target_link_libraries(curltest $&#123;CURL_LIBRARY&#125;)else(CURL_FOUND) message(FATAL_ERROR ”CURL library not found”)endif(CURL_FOUND) ​ 对于系统预定义的 Find&lt;LibaryName&gt;.cmake 模块，使用方法一般如上例所示。 ​ 每一个模块都会定义以下几个变量 &lt;LibaryName&gt;_FOUND &lt;LibaryName&gt;_INCLUDE_DIR or &lt;LibaryName&gt;_INCLUDES &lt;LibaryName&gt;_LIBRARY or &lt;LibaryName&gt;_LIBRARIES ​ 你可以通过&lt;LibaryName&gt;_FOUND 来判断模块是否被找到，如果没有找到，按照工程的需要关闭 某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。 如果&lt;LibaryName&gt;_FOUND 为真，则将&lt;LibaryName&gt;_INCLUDE_DIR 加入 INCLUDE_DIRECTORIES， ​ 通过find_package引入非官方的库（该方式只对支持cmake编译安装的库有效）​ 假设此时我们需要引入glog库来进行日志的记录，我们在Module目录下并没有找到 FindGlog.cmake。所以我们需要自行安装glog库，再进行引用。 ​ 安装 12345678910# clone该项目git clone https://github.com/google/glog.git # 切换到需要的版本 cd gloggit checkout v0.40 # 根据官网的指南进行安装cmake -H. -Bbuild -G \"Unix Makefiles\"cmake --build buildcmake --build build --target install ​ 此时我们便可以通过与引入curl库一样的方式引入glog库了 12345678find_package(glog)add_executable(glogtest glogtest.cc)if(GLOG_FOUND) # 由于glog在连接时将头文件直接链接到了库里面，所以这里不用显示调用target_include_directories target_link_libraries(glogtest glog::glog)else(GLOG_FOUND) message(FATAL_ERROR ”glog library not found”)endif(GLOG_FOUND) ​ Module模式与Config模式​ 通过上文我们了解了通过Cmake引入依赖库的基本用法。知其然也要知其所以然，find_package对我们来说是一个黑盒子，那么它是具体通过什么方式来查找到我们依赖的库文件的路径的呢。到这里我们就不得不聊到find_package的两种模式，一种是Module模式，也就是我们引入curl库的方式。另一种叫做Config模式，也就是引入glog库的模式。下面我们来详细介绍着两种方式的运行机制。 ​ 在Module模式中，cmake需要找到一个叫做Find&lt;LibraryName&gt;.cmake的文件。这个文件负责找到库所在的路径，为我们的项目引入头文件路径和库文件路径。cmake搜索这个文件的路径有两个，一个是上文提到的cmake安装目录下的share/cmake-&lt;version&gt;/Modules目录，另一个使我们指定的CMAKE_MODULE_PATH的所在目录。 ​ 如果Module模式搜索失败，没有找到对应的Find&lt;LibraryName&gt;.cmake文件，则转入Config模式进行搜索。它主要通过&lt;LibraryName&gt;Config.cmake or &lt;lower-case-package-name&gt;-config.cmake这两个文件来引入我们需要的库。以我们刚刚安装的glog库为例，在我们安装之后，它在/usr/local/lib/cmake/glog/目录下生成了glog-config.cmake文件，而/usr/local/lib/cmake/&lt;LibraryName&gt;/正是find_package函数的搜索路径之一。（find_package的搜索路径是一系列的集合，而且在linux，windows，mac上都会有所区别，需要的可以参考官方文档find_package） ​ 由以上的例子可以看到，对于原生支持Cmake编译和安装的库通常会安装Config模式的配置文件到对应目录，这个配置文件直接配置了头文件库文件的路径以及各种cmake变量供find_package使用。而对于非由cmake编译的项目，我们通常会编写一个Find&lt;LibraryName&gt;.cmake，通过脚本来获取头文件、库文件等信息。通常，原生支持cmake的项目库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。 ———————————————— 参考链接：https://github.com/BrightXiaoHan/CMakeTutorial/tree/master/FindPackage ​ add_executable &amp; add_library12add_exectuable() 告诉工程生成一个可执行文件。add_library() 则告诉生成一个库文件。 ​ include_directories1include_directiories(/usr/include/curl) ​ 指定头文件目录在/usr/include/curl ​ target_link_libraries1target_link_libraries(myprogram path/curl.so) ​ 指定库文件目录在myprogram path/curl.so ​ include_directories与target_include_directories的区别​ include_directories(x/y)影响目录范围。CMakeList中的所有目标，以及在其调用点之后添加的所有子目录中的目标，都会把路径x/y添加到它们的包含路径中。 ​ target_include_directories(t x/y)有目标范围–它将x/y加入到目标t的包含路径中。 ———————————————— 参考链接：https://stackoverflow.com/questions/31969547/what-is-the-difference-between-include-directories-and-target-include-directories ​ ​ 几种include1234# CMake的几种includeinclude_directories（）target_include_directories（）add_executable( xx.cpp xx.h) ​ 这三种方式都可以对当前项目添加引用路径。 ​ include_directories（）​ include_directories（）的影响范围最大，可以为CMakelists.txt后的所有项目添加头文件目录。 ​ 一般写在最外层CMakelists.txt中影响全局。 ​ target_include_directories（）​ target_include_directories（）的影响范围可以自定义。如加关键子PRIVATE或这PUBLIC。 ​ 一般引用库路径使用这个命令，作为外部依赖项引入进来，target是自己项目生成的lib。 12project(myLib)target_include_directories（myLib PRIVATE $&#123;OpenCV_Include_dir&#125;） ​ 就表示将${OpenCV_Include_dir}头文件库路径只添加到了myLib项目 ​ add_executable（）​ add_executable( )中添加的引用路径一般是当前目录下的源文件对应的头文件。是生成项目时引入的头文件。 ​ 这种方式一般用于自己写的或某项目需要的头文件，这种方式需要加添加文件名字，而非头文件目录。 ​ 如： 12project(addFunc)add_executable（addFunc addFunc.h addFunc.cpp） ————————————————参考链接：https://blog.csdn.net/fb_help/article/details/81382746 ​ target_compile_definitions​ 为目标增加编译定义（可以理解为，这是个什么文件）。 1234target_compile_definitions(&lt;target&gt; &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...] ) ​ 例子： 123target_compile_definitions(thirdparty_llvm INTERFACE $&#123;LLVM_DEFINITIONS&#125;) ​ 说明thirdparty_llvm是LLVM文件，用LLVM编译。 ​ foreach1234567foreach(LLVM_LIB IN LISTS LLVM_AVAILABLE_LIBS) get_target_property(LLVM_LIB_TYPE $&#123;LLVM_LIB&#125; TYPE)// lib类型是静态库，就把它加到LLVM_LIBRARIES里面 if(LLVM_LIB_TYPE STREQUAL \"STATIC_LIBRARY\") list(APPEND LLVM_LIBRARIES \"$&#123;LLVM_LIB&#125;\") endif()endforeach() ​ 以foreach()开头，以endforeach()结尾的循环。 ​ math1math(EXPR REMILL_LLVM_VERSION_NUMBER \"$&#123;LLVM_MAJOR_VERSION&#125; * 100 + $&#123;LLVM_MINOR_VERSION&#125;\") ​ 计算 ${LLVM_MAJOR_VERSION} * 100 + ${LLVM_MINOR_VERSION}，并将结果返回到EXPR REMILL_LLVM_VERSION_NUMBER ​ CMAKE_HOST_SYSTEM_PROCESSOR​ CMAKE正在运行的CPU的名字 ​ CMAKE_ENABLE_EXPORTS​ 指定可执行文件是否为可加载模块导出的option ​ message​ message :为用户显示一条消息 12message( [STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] \"message to display\" ...) ​ 可以用下述可选的关键字指定消息的类型： 123456(无) = 重要消息； STATUS = 非重要消息； WARNING = CMake 警告, 会继续执行； AUTHOR_WARNING = CMake 警告 (dev), 会继续执行； SEND_ERROR = CMake 错误, 继续执行，但是会跳过生成的步骤； FATAL_ERROR = CMake 错误, 终止所有处理过程； ​ 编译选项​ 在remill源码里看到了这一段，描述了VS编译器的编译选项。 123456789target_compile_options(remill_settings INTERFACE \"$&lt;$&lt;CONFIG:Debug&gt;:/MDd&gt;$&lt;$&lt;CONFIG:Release&gt;:/MD&gt;\" /nologo /W3 /EHsc /wd4141 /wd4146 /wd4180 /wd4244 /wd4258 /wd4267 /wd4291 /wd4345 /wd4351 /wd4355 /wd4456 /wd4457 /wd4458 /wd4459 /wd4503 /wd4624 /wd4722 /wd4800 /wd4100 /wd4127 /wd4512 /wd4505 /wd4610 /wd4510 /wd4702 /wd4245 /wd4706 /wd4310 /wd4701 /wd4703 /wd4389 /wd4611 /wd4805 /wd4204 /wd4577 /wd4091 /wd4592 /wd4324) ​ 那么这么多的编译选项，是什么意思呢？ ​ /nologo表示编译时不在输出窗口显示这些设置 ​ EH（异常处理模型）1&#x2F;EH&#123;s|a&#125;[c][-] 此选项指定编译器使用的异常处理模型。 使用 /EHs 指定同步异常处理模型（没有结构化异常处理异常的 C++ 异常处理）。如果使用 /EHs，不要依靠编译器捕捉异步异常。 使用 /EHa 指定异步异常处理模型（带结构化异常处理异常的 C++ 异常处理）。 /EHc 选项要求指定 /EHs、/EHa 或 /GX。它通知编译器假定 extern C 函数从不引发异常。 上面的源码里有 /EHsc编译选项。不依靠编译器捕捉异步异常，且通知编译器假定 extern C 函数从不引发异常。而remill源码中也出现了很多 extern C，这是合理的。 ———————————————— 参考链接： https://blog.csdn.net/zhou_ml/article/details/1470452 https://blog.csdn.net/dongfengkuayue/article/details/47044179 ​ private、public、interface的区别The PUBLIC, PRIVATE and INTERFACE keywords can be used to specify both the link dependencies and the link interface in one command. Libraries and targets following PUBLIC are linked to, and are made part of the link interface. Libraries and targets following PRIVATE are linked to, but are not made part of the link interface. Libraries following INTERFACE are appended to the link interface and are not used for linking &lt;target&gt;. PUBLIC, PRIVATE和INTERFACE关键字可以用来在一条命令中指定链接依赖关系和链接界面。在PUBLIC后面的库和目标被链接到，并成为链接界面的一部分。在PRIVATE后面的库和目标被链接到，但不成为链接界面的一部分。在INTERFACE后面的库被附加到链接界面上，并且不用于链接。 ​ optionoption是什么​ option提供用户可选择的选项。 12option(&lt;option_variable&gt; \"help string describing option\" [initial value]) ​ 用户可将option选择为 ON 或 OFF。如果未提供初始值，则使用 OFF。 ​ remill源码举例： 12option(REMILL_BARRIER_AS_NOP \"Remove compiler barriers (inline assembly) in semantics\" OFF)option(REMILL_BUILD_SPARC32_RUNTIME \"Build the Runtime for SPARC32. Turn this off if you have include errors with &lt;bits/c++config.h&gt;, or read the README for a fix\" ON) ​ 每个option的描述性文字，大大方便了理解代码。 ​ option的使用场景CMake option使用场景 : 编译脚本传递参数 -&gt; CMake脚本接收option -&gt; 源代码宏。 ​ 编译脚本传入参数 传入一个cmake option TEST_DEBUG 1234#!/bin/shcmake -DTEST_DEBUG=ON .cmake --build . ​ CMake脚本接收option cmake 脚本定义TEST_DEBUG 默认关闭OFF 1234567project(test)option(TEST_DEBUG \"option for debug\" OFF)if (TEST_DEBUG)add_definitions(-DTEST_DEBUG)endif()... ​ 源代码宏 test.c 12345#include \"test.h\"#ifdef TEST_DEBUG...#endif ———————————————— 参考链接（这个写的挺清晰的）：https://www.jianshu.com/p/035bc18f8f62 extern C​ extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，**为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern &quot;C&quot;就是其中的一个策略。**​ 这个功能主要用在下面的情况： C++代码调用C语言代码 在C++的头文件中使用 在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到 ———————————————— 参考链接：https://www.cnblogs.com/xiangtingshen/p/10980055.html ​ ​ 宏​ 宏（英语：Macro）是一种批量处理的称谓。 ​ 计算机科学里的宏是一种抽象（Abstraction），它根据一系列预定义的规则替换一定的文本模式。解释器或编译器在遇到宏时会自动进行这一模式替换。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。 ​ 宏这一术语也常常被用于许多类似的环境中，它们是源自宏展开的概念，这包括键盘宏和宏语言。绝大多数情况下，“宏”这个词的使用暗示着将小命令或动作转化为一系列指令。 ​ #define 这样的就是宏。 ​ ​ ​ ​ 搭docker跑remill​ 想做 ​ ​ ​ ​ 各种文件类型​ lib​ LIB有两种，一种是静态库，比如C-Runtime库，这种LIB中有函数的实现代码，一般用在静态连编上，它是将LIB中的代码加入目标模块(EXE或者DLL)文件中，所以链接好了之后，LIB文件就没有用了。一种LIB是和DLL配合使用的，里面没有代码，代码在DLL中，这种LIB是用在静态调用DLL上的，所以起的作用也是链接作用，链接完成了，LIB也没用了。至于动态调用DLL的话，根本用不上LIB文件。 目标模块（EXE或者DLL）文件生成之后，就用不着LIB文件了。 ​ dll​ .dll，动态链接库。英文为DLL，是Dynamic Link Library的缩写。DLL是一个包含可由多个程序，同时使用的代码和数据的库。 ​ 优势是可以更为容易地将更新应用于各个模块，而不会影响该程序的其他部分。例如，您可能具有一个工资计算程序，而税率每年都会更改。当这些更改被隔离到 DLL 中以后，您无需重新生成或安装整个程序就可以应用更新。 ​ ​ 环境变量与系统变量​ 在装软件的时候我们往往要配置环境变量。这是为什么呢？ ​ 环境变量是为了调用方便 ​ 1、软件依赖项。 ​ 比如java，很多软件会用到，如果不加入到环境变量，当需要调用java的时候就要指定java.exe的完整路径，如c:\\program files\\java\\xxxxx\\vvvv\\java.exe，指定完整路径不要紧，问题是完整路径根本不知道，可能在D盘，也可能在E盘，不知道路径没法调用。加入到环境变量，其他软件直接call 一下 java.exe就行。管你在哪儿，os 帮你唤醒。 ​ 2、方便。 ​ 其实我感觉和上一条差不多，比如我们要打开注册表，运行，输入regedit就行，如果没有环境变量，就需要输入c:\\windows\\system32\\regedit.exe。 ​ 3、系统路径。 ​ 比如有的软件想要到windows目录写入自己的文件，有些脚本语言是并没有类似的GetWindowsDirectory等函数获取windows目录，那可以直接使用类似%windir%的方式，直接切换到需要的系统路径。 作者：单纯的淫链接：https://www.zhihu.com/question/381822915/answer/1099137710 ​ ​ 那么环境变量和系统变量是什么呢？ 环境变量​ 环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。 ​ 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如Windows和DOS操作系统中的path环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境变量，来更好的运行进程。 ​ path 表示：指定可执行文件的搜索路径。 ​ 实际上我们用的最多的也是这个变量，在我们安装各种软件，搭建各种开发环境时，一般也都是直接在这个path里面放入配置程序路径的。 ​ 为了安全一般配置用户环境变量；为了省事一般配置系统环境变量。 ​ 系统变量​ 系统变量是由操作系统定义的数据存储位置，无论谁登录该计算机，该位置都相同。Administrators 组（即管理员用户组）的用户可以添加新的变量或更改这些值。 ———————————————— 参考链接（这个写的挺清晰的）：https://jingyan.baidu.com/article/a17d5285c9b0c48099c8f26a.html ​ ​ ​ ​ 一份笔记，没看，mark一下https://sfumecjf.github.io/cmake-examples-Chinese/01-basic/1.7%20%20Including%20Third%20Party%20Library.html","categories":[],"tags":[{"name":"大学专业课","slug":"大学专业课","permalink":"http://glisses.github.io/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"认知神经科学导论期末复习","slug":"认知神经科学导论期末复习","date":"2021-06-29T02:19:13.000Z","updated":"2021-06-29T17:19:36.520Z","comments":true,"path":"2021/06/29/认知神经科学导论期末复习/","link":"","permalink":"http://glisses.github.io/2021/06/29/%E8%AE%A4%E7%9F%A5%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","excerpt":"第一章 概述和简史什么是认知神经科学“认知”即直觉和认识的过程，而“神经科学”则是研究神经系统的学科，因此，认知神经科学描述了“有形大脑的功能如何产生无形心智的思维和想法”。 颅相学颅相学宣称大脑有35个左右的特异性功能，这些功能由特异性脑区负责，从语言、颜色到希望和自尊。经常应用某些能力会导致大脑相应部分长大，进而导致头骨的突起，因而根据头颅形状可以描述人格，这被称为解剖人格学。并非所有人都赞成“定位主义”，生理学家Flourens研究鸟类，发现不管损伤哪个部位，鸟都可以恢复。他发展了“聚集场理论”：大脑作为一个整体参与行为。（1824）","text":"第一章 概述和简史什么是认知神经科学“认知”即直觉和认识的过程，而“神经科学”则是研究神经系统的学科，因此，认知神经科学描述了“有形大脑的功能如何产生无形心智的思维和想法”。 颅相学颅相学宣称大脑有35个左右的特异性功能，这些功能由特异性脑区负责，从语言、颜色到希望和自尊。经常应用某些能力会导致大脑相应部分长大，进而导致头骨的突起，因而根据头颅形状可以描述人格，这被称为解剖人格学。并非所有人都赞成“定位主义”，生理学家Flourens研究鸟类，发现不管损伤哪个部位，鸟都可以恢复。他发展了“聚集场理论”：大脑作为一个整体参与行为。（1824） 布洛卡区和威尔尼克区1861年，法国的Paul Broca的著名案例——表达性失语症。卒中的病人可以听懂别人说话，唇、舌、喉都正常，但除了“tan”音之外无法正常说话。解剖发现其左侧额叶下部有损伤，后来被称为Broca区。1876年，德国的Carl Wernicke报告了 听觉性失语症。病人可以讲话，但他听不懂别人和自己的讲话，也不能理解书面语言。其大脑在左半球颞上回后部受损。这就是Wernicke区。 第一章小结 Willis 在17世纪提出了这样一种观点: 脑损伤会影响行为,并且大脑皮质可能确实是使我们成其为人的物质基础。 颅相学家拓展了这种观点，并且发展出定位主义观点。 后来, Broca和 Wernicke所治疗的那类病人支持了特定脑区对人类行为（如语言）有重要作用这一观点。 Cajal、Brodmann等人发现的不同脑区的微观生神经结构支持定位主义观点,但这些区域是相互连接的。很快,科学家开始意识到,大脑神经网络的整合才可能产生心智。 第二章 细胞机制与认知神经系统的细胞 神经系统由两种细胞构成：神经元和神经胶质细胞 神经元：神经信息传递和信息加工（电学、化学） 胶质细胞：框架、绝缘、清理、屏障，复杂的智能，具体如下：形成支持神经元分布的框架；在脑的发育过程中找到自己适当的位置；促进或直接参与神经纤维髓鞘的形成，在神经信息传导中其绝缘作用，提高传递速度；清洁，吸收过量的神经递质并清理受损或者死亡的神经元；形成血脑屏障，使毒物和其他有害物质不能进入脑内；影响信息传递的离子浓度；与神经元之间可能存在多时间尺度的信息交流并行网络，参与复杂的智能活动； 神经元神经元是基本的信号处理单位。神经元接收信息，遵循某些相当简单的规律作出“决定”，然后改变自己的活动水平，最后将信息传递给其他神经元。这些功能与神经元的形态或结构的特异性密切相关。 神经元的组成成分之一是细胞体，细胞体内有维持神经元新陈代谢的细胞器，包括细胞核，内质网，核糖体，线粒体，高尔基器等，这些结构被神经元的双层脂质细胞膜包围，悬浮在细胞质中。 树突：大树样突起，接受来自其他神经元的传入信息，具体接收部位被称为“突触”。对信息流而言，树突是位于突触后面的结构，又被称为突触后。轴突：远离胞体的突起，是神经元的输出端。位于突触前面的结构，被称为突触前。 一般情况下，大多数神经元都同时既是突触前又是突触后：当它们的轴突与其他神经元建立连接时，它们是突触前；当其他神经元与它的树突建立连接时，它又是突触后。 神经元活动涉及电位改变，但神经元间突触的传递信号通常是化学信号，少数情况下，神经元彼此间传递信号为电信号。 突触神经元细胞之间的通信是通过突触完成的。突触是指一个神经元的冲动传到另一个神经元或传到另一细胞间的相互接触的结构。 突触的类型突触可以分为： 轴-体突触 轴-轴突触 轴-树突触 树-树突触 神经系统的构成 中枢神经系统：星形细胞形成血脑屏障；少突胶质细胞形成髓鞘（一个细胞形成多个髓鞘）；小胶质细胞修补或清理损伤神经元。 外周神经系统：失望细胞形成髓鞘（一个细胞形成一个髓鞘） 星形细胞星形胶质细胞是一种呈圆形或放射对称形状的大细胞，它们围绕着神经元并与脑血管紧密连接。 星形胶质细胞与脑血管的接触部位特化为终足,该结构既允许离子进出血管壁又在中枢神经系统的组织与血液之间构建了一道屏障。这种神经组织与血液之间的星形胶质细胞屏障被称为血脑屏障(lood–brain barrier, BBB)。 该屏障能阻挡某些血液传播的病原或过度影响神经活性的化学物质的进入,从而在保护中枢神经系统中发挥至关重要的作用 许多药物不能穿过BBB，某些神经激活因子如多巴胺和去甲肾上腺素一旦位于血液中，也不能通过BBB。 神经元信息交流神经元是构成神经系统的完整的功能单位。 每个神经元通常通过位于树突或胞体的突触来实现与其他神经元的信息交流。传出信息是通过轴突末梢的突触实现的。神经元加工信息的目的是接受信息，评估信息，然后将型号传递给其他神经元，由此构成局部或长程神经环路。 神经元的一种典型的信号加工过程 神经元接收信号，包括化学的（神经递质），物理的（皮肤触感，眼睛接受光线） 信号引起突触后神经元细胞膜的变化，导致电流流入或流出 电流在神经元内发挥信号左右，并影响远离传入突触位点的神经元膜 电流由离子流传到，被整合后成为动作电位，最终沿轴突下行传播到轴突末梢，引起突触神经递质的释放。 细胞膜内外电位差在-40至-90mV ！！！神经元信号传导概述！！！考主观题。 当细胞从突触接受到刺激之后，会打开细胞膜上面的离子通道，让钠离子流入，造成去极化 (depolarization)，也就是细胞里面的电位有些微的上升，被称为兴奋性突触后电位。也可能产生超极化（hyperpolarization），将使细胞内电位下降，更趋负性。 跳跃式传导和髓鞘的作用 突触传递神经信号的最终作用是实现神经元间或者神经元与肌肉的信息交流。为实现这一作用，神经元必须要传递信号，这就是突触传递。突触有两种类型：化学突触和电突触化学传递的步骤：首先，一个动作电位到达突触所在的轴突末梢，引起末梢的去极化，引起Ca2+内流Ca2+浓度的增高导致含有神经递质的小囊泡与突触膜融合，并将神经递质释放至突触间隙神经递质扩散至突触后膜，与嵌在突触后膜的蛋白质分子（受体）结合，启动突触后膜的变化 第三章 神经解剖和发展解剖学分区 布罗德曼分区 Brodmann 分区的编号意味着Brodmann分离出这个脑区的编号，但在一些区域中，编号系统与功能相关的脑区之间存在粗略的对应关系。比如17,18和19区都与视觉功能相关。 同一区域可能有一个Brodmann分区名、一个细胞结构学的命名、一个大体解剖学的命名或者一个功能命名。比如Brodmann分区的17区（BA17），细胞结构学的命名为纹状皮层，大体解剖学上叫做距状裂皮质，从功能角度叫做初级视皮层。在对猴子视觉的研究中，将其命名为V1区（visual area 1）。 在大脑的很多区域，不同命名法代表的区域并不相同。 大脑皮质——功能分区大脑皮质的各叶在神经加工过程中发挥着多方面的作用，虽然主要的功能系统一般都可以定位在某个脑叶中，但是也有很多系统是跨脑叶的。 大脑中的认知系统通常有不同的神经网络组成，这些组成成分位于皮质的不同区域。 脑的大部分功能都需要皮质和皮质下结构的共同作用，不论是感觉、运动还是认知功能都是如此。 几个重要的分区：运动、躯体感觉、视觉加工、听觉加工、联合皮质。 额叶中的运动区额叶既包括运动区，也包括更高级的联合皮质，例如前额叶与执行功能、记忆及其他认知加工过程有关。 顶叶中的躯体感觉区 皮质拓扑地形图 枕叶中的视觉加工区域 颞叶中的听觉加工区域 神经系统的发育 新神经元的产生在啮齿类动物中,已有研究发现成年个体海马齿状回中的干细胞可以产生新的神经元,它们还可以迁移至已在发生作用的相似神经元所在的海马区域。重要的是,这些新神经元可以沿这一海马区域神经元所应有的路径形成树突和发出轴突,并显示出正常的突触活动。这些发现很有意思,因为新神经元的数目与学习和经验的丰富程度(物理环境中更多的社会接触与挑战)成正相关,而与压力(如居住在过于拥挤的环境中)成负相关。并且,新神经元的数目还与依赖于海马的记忆有关(Shors，2004) 出生后大脑的发育另有实验表明成人大脑中也有新神经元的产生,而且我们的大脑一生都在自我更新,并达到我们以往认为不可能的程度。 神经元发育的一个重要方向是突触生成。突触生成从受孕的27周开始，到出生后的15个月才达到顶峰​ 同时，大脑中的神经元的树突分支在增加，轴突延长并产生髓鞘。 随之而来的是突触削减，会持续十多年时间。 突触削减是神经系统对连接进行微调的方式，一般认为会清除那些多余的或者不起作用的连接。 对于不同的皮质区域，突触的生成与削减的时间进程不同，即人类大脑的不同区域在不同时期达到成熟。 对突触的数量的测量 用磷钨酸法来染色蛋白质，计算听皮质和前额叶皮质的突触数量，标本从孕28周到59岁。结果发现听皮质早于联合皮质约3个月达到顶峰。 葡萄糖代谢量的测量 用 PET测量，结果发现葡萄糖代谢量在新生儿时期快速增加，在青少年时期减少。 第四章 认知神经科学研究方法1我们对刺激存在多重表征 动物实验技术单细胞技术、损伤、遗传控制、新基因组学 单细胞记录在神经科学中，最重要的一项技术就是在动物中记录单个神经元的活动的方法。单细胞记录使得研究者能够描述单个元素的反应特性在单细胞记录中，一个微电极插入动物的脑中，如果电极在一个细胞的旁边，就可以测量到细胞电活动在经典的神经生理学实验中，研究者从感兴趣的目标区域中选择一系列细胞进行记录没有刺激时，神经元有自己的基线活动。不同位置的神经元的自发放电活动各不相同研究者试图通过建立细胞活动与特定刺激模式或行为之间的相关来确定单个神经元的反应特性视觉细胞的感受野大小有所不同。初级视皮质最小，在联合视觉区域中变的更大。因此，只有当刺激处于视觉世界中一个非常限定的区域中时，该刺激才会引起初级视皮质细胞增加放电频率，该刺激在一个很大的距离范围内移动，都可能会引起颞叶视觉敏感细胞的放电频率增加相邻的细胞至少有一部分重叠的感受野（防止有细胞坏了）。由于在一个区域中视觉反应细胞是横向排列的，因此这些细胞的感受野属性与外部视觉存在有序的关系。外部空间是以连续的方式在皮质表面进行表征的。即细胞群形成一个拓扑地形表征。在视觉中，被称为视网膜区域定位。如果光落在视网膜某一点，则感受野包含这一区域的细胞就被激活，如果光线移动然后落在视网膜的另外一个区域，这些细胞活动就会停止。这样，视觉区域为刺激的位置提供了表征。 耳蜗区域定位 损伤神经生理学中一个长期使用的方法：通过选择性的去除一个或多个结构来研究行为会发生怎样的改变。这在动物研究中很常见。比如诺贝尔奖获得者Sherrington在20世纪初引入损伤法在狗身上研究反馈在肢体运动中的重要性损伤一个神经结构可以消除该结构的作用，但也可能强迫动物改变它们的正常行为，以及改变未收损伤结构的功能。与损伤区域连接的神经区域的功能可能会改变。损伤也可能会使动物发展出代偿的策略。代偿：有个实验，去掉猴子对左手的知觉，猴子用右手；去掉双手的知觉，反而开始轮流使用双手。 最初的损伤是通过抽取神经组织来实现，或者用足够强的电流破坏组织。其问题是很难做到选择性。较新的方法是神经化学损伤。 有时药物可以选择性的破坏那些使用特定神经递质的细胞。比如，全身注射MPTP会破坏黑质中的多巴胺能细胞，引起动物的帕金森症状。 其他化学损伤需要把药物使用到目标区域中。比如红藻氨酸，会破坏注射部位附近的神经元细胞体，但不会对轴突纤维产生影响。 遗传控制研究者采用果蝇和老鼠来进行研究，采用基因敲除程序，培养转基因动物。敲除是指对特定基因进行处理，使其不再存在或表达这些转基因动物可以进行研究，比如织布鼠，是敲除了小脑的主要细胞的品种基因敲除程序被用于创造在特定脑区缺乏单一类型突触后受体但完整保留其他类型受体的物种。比如，改变海马一个亚区内的细胞，这种基因敲除鼠用于进行记忆任务研究 神经损伤的结构性成像脑损伤可能由血管疾病、肿瘤、退行性病变和外伤等引起，神经病学家将脑结构可视化，进行诊断 计算机断层扫描（CT）1983年实现商用，是X射线的升级版，传统X射线把三维物体压缩成二维，而CT则可以通过压缩的二维图像重构三维空间CT的基本原理是生物物质的密度不同，对X射线的吸收能力与组织密度相关。高密度的物质，如骨头，吸收大量射线，而低密度物质，如空气或血液，吸收射线很少。神经组织介于两者之间。因此，CT扫描的软件提供的是介质组织不同吸收能力的图像CT机包括两个部分：X射线源和射线探测器，两者位置相对。射线源和探测器可以旋转，直到在180°都投射过。计算机将得到的图像进行三维重建CT的空间分辨率接近0.5-1厘米。由于皮质只有4毫米厚，因此无法分辨白质和灰质，但头骨是白色的，脑室是黑色的 磁共振成像MRIMRI利用有机体组织的磁特性，某些特定原子核中的质子和中子数使得这些原子对磁力特别敏感。比如遍布于整个大脑和其它有机体组织的氢原子。MRI扫描中的区域被称为体素。MRI产生一个单位为特斯拉的强大磁场，典型的MRI为0.5T-1.5T。当一个人进入MRI的磁场中时，相当大部分的质子变得与磁力线方向平行排列。无线电波穿过磁区域，当质子吸收了这些电波的能能量后，它们会指向一个可预测的方向。当无线电波关闭后，吸收的能量消散，质子重新朝向磁场方向。这种同步反弹产生的能量能被周围探测器接收。通过系统地测量整个头部的三维信号，MRI系统可以建构反映组织中质子和其他磁性物质分布的图像。MRI的图像比CT更清晰，灰质与白质可以区分。通过MRI，可以看到大脑皮质的各个沟回。MRI的分辨率小于1毫米，能清晰的看到上丘等皮质下结构。效果好而且辐射小。MRI可用于研究形成白质的轴突束的显微解剖结构。 弥散张量成像（DTI）DTI测量的是轴突中水的密度，以及水的运动信息。DTI利用已知的水的扩散特性来确定大脑中限制水运动的边界。大脑中的水的扩散是各向异性的，原因是轴突细胞膜限制了水的扩散。水沿着轴突运动的可能性要大于垂直于轴突运动。轴突中的各向异性最强。因为髓鞘形成了脂质边界，对水的限制比灰质或者脑脊液要大的多。通过这样的方法，可以对白质中轴突束的朝向进行成像。 退行性疾病和感染性疾病（神经系统）神经退行性疾病与基因缺陷和环境因素有关，是由神经元和（或）其髓鞘的丧失所致，随着时间的推移而恶化，出现功能障碍。感染性疾病是由于病人在治病期间，由于体质和抵抗病菌能力较差，而被感染其它疾病。像刚做过手术的人，不注意对刀口消毒和保护，容易被感染而不易愈合。还有的病人由于动了大手术，在愈合期间，引起肺炎，这叫感染性肺炎。像白求恩就是因为手上的刀口被细菌感染而不治身亡的。帕金森症，退行性疾病，主要与环境因素有关，多巴胺能神经元丧失导致。帕金森氏症，可能与一种环境积累的未知毒素加速了多巴胺能神经元的死亡有关。Pick病，退行性，额颞叶萎缩导致。 基因缺陷引起的疾病——亨廷顿氏舞蹈症阿尔兹海默症，5%可能与基因有关。一个主流的假设，有机体组织内一种普遍存在的淀粉样蛋白质的生成发生了错误，从而导致在患者的大脑中发现特有的斑块。 小结——神经科学技术和工具单细胞记录使得神经生理学家能够记录动大脑的单个神经元,从而理解与某个感受和行为刺激相关的神经元活动是如何增加或减少的通过多细胞记录,数百个细胞的活动可以同时记录。不管是自然发生(在人类中)还是实验引发(在动物中)的脑损伤,都能够使研究者可以检验有关脑损伤区域的功能的假设。基因敲除技术使得科学家可以探索特定基因表达计算机断层扫描(CT或CAT)采用X射线对脑结构进行成像。磁共振成像(MRI) 利用大脑有机组织的磁特进行结构成像。MRI的空间分辨率比CT要好弥散张量成像(DTI) 通过磁共振扫描仪进行,被用于测量脑内的白质通路。血管造影术被用于评估脑循环系统。 第五章 认知神经科学研究方法2经颅磁刺激TMS是无创！是产生局部刺激！是好的！TMS被用于探讨多个不同脑区的作用。如线圈置于运动皮质控制手活动的区域时，刺激会激活手腕和手指的肌肉这种方法可以评估运动通路的完整性。 TMS能探测运动骨皮质的兴奋性。TMS发现，在理解别人的姿势的过程中，观察他人的动作会激活运动系统。 TMS引起“虚拟损伤”：通过刺激，研究者选择性的干扰一个特定皮质区域的正常活动。 安全和无创性的，产生相对短暂的神经活动改变。 虚拟损伤用于刺激多个大脑区域。刺激视觉皮质会干扰个体辨认字母的能力（Corthout等，1999） 经颅磁刺激TMS的局限性效应十分短暂。TMS刺激与感觉刺激事件或者运动紧密联系时，这一方法效果最好。刺激只能激活皮质的有限区域。优势是可以将刺激限制在一个特定的区域内，劣势是无法探索不在大脑表层的皮质区域。联合其他方法应用效果最好，比如磁共振成像MRI。 电信号-脑电图EEG检测大群神经元共同活动产生的电位优点：安全，方便，成本低毫秒级的时间分辨率厘米级的空间分辨率 正电子发射断层扫描（PET） 有损PET测量的是与心理活动相关的局部脑血流变化。需要向血流中注入示踪剂，即放射性元素（同位素）同位素中，正电子会从原子核中发射出来，导致衰变，当正电子与一个箱子相撞时，会产生两个光子，即伽马射线。PET——伽马射线探测器——检测到碰撞在哪里发生。重构的图像可以显示血流的分布 ERP事件相关电位EEG重复几十上百次，叠加平均得到消去干扰的波形。ERP电位图是反着的啊，就x轴上方是负的，下方是正的。 fMRI功能磁共振成像过程：电波是氢原子的质子振动，检测器测量当质子回到外部磁场方向时所产生的局部能量场fMRI成像关注血红蛋白的磁场特性。fMRI探测器测量氧合和脱氧血红蛋白的比率，这个比率被称为“血氧水平依赖效应”（BOLD）在活动组织中，BOLD是上升还是下降？直觉上，脱氧组织比例变大，但fMRI报告氧和对脱氧比率增加，原因是大脑区域激活时，流向该区域的血量增加。虽然神经时间以毫秒为时间单位，但血流慢的多，在6-10秒达到峰值。 fMRI的特点与PET相比，实验更加方便，医院几乎都有，PET设备需要更多人员fMRI不需要注射放射性示踪剂，一个被试可以反复测试（无损）fMRI的空间分辨率更高，达到3立方毫米，同时能提供高分辨率的解剖图像，定位更好。正电子发射断层扫描PET在对齐时会引入误差fMRI可以用于提高时间分辨率。PET的实验任务需要至少40秒，然后这段时间内的活动被平均。fMRI信号改变同样要求对连续观察的平均。 新陈代谢信号 一张图小结 第六章 感觉和知觉基底膜 毛细胞 耳蜗内耳将声音转换为神经信号。到达耳朵的声波使耳鼓振动，振动在内耳液中产生小波，刺激排布于基底膜表面的细小的毛细胞毛细胞是初级听觉感受器，基底膜的振荡引起毛细胞发生动作电位基底膜和毛细胞位于耳蜗中毛细胞具有编码声音频率的感受野，人耳的听觉范围20Hz-20000Hz，其中1000Hz-4000Hz最敏感自然声音具有复杂的频率，会激活大范围的毛细胞 听觉的计算目标 声音的多重线索 眼睛结构感光细胞有两种类型：视杆细胞和视锥细胞视杆细胞对低强度的刺激敏感，在光能很少的晚上有用视锥细胞活动需要强烈的光线，使用能快速再生的感光色素，在日间活动中最强视锥细胞是颜色视觉的基础，可以分为红、绿或蓝三种，对不同可见光的敏感性不同 视杆细胞和视锥细胞在视网膜上并不是均匀分布的视锥细胞在视网膜的中央最为集中，这一区域被称为“中央凹”视杆细胞则在整个视网膜上都有分布 从眼睛到中枢神经系统在进入大脑之前，每条视神经分成两部分。颞侧（外侧）的分支继续同侧传递，而内侧的分支则投射到对侧，形成视交叉由于视交叉的存在，左视野的所有信息被投射到大脑右半球，右视野的所有信息被投射到左半球进入大脑后，视神经终止于不同的皮质下结构视网膜——外侧膝状体（LGN）——初级视皮质（90%的视神经轴突）视网膜——丘脑枕核/上丘（10%，与视觉注意有关）到达皮质的视觉信息至少被四类不同神经元加工过：感光细胞、双极细胞、神经节细胞和外侧膝状体细胞 第七章 物体识别视知觉的两条皮质通路 背侧和腹侧通路的表征差异颞叶和顶叶神经元的生理特性十分不同。 两个区域的神经元都具有大的感受野。顶叶的神经元以非选择性方式反应。例如， 当刺激是一个局限于小范围的光点或者是一个占据了半个视野的大部分区域的大物体时， 清醒猴的顶叶神经元可能会被激活。许多顶叶神经元对呈现于视野非中心位置的刺激有反应。 颞叶神经元的感受野总是包围着中央凹，大多数这些神经元可以被落入左或右视野的刺激激活颞叶视觉区域的细胞有多种选择模式。在采样的 151 个细胞中， 110 个至少对一种刺激有恒定反应。 这些细胞有 41% 与顶叶神经元类似： 它们可以被任何刺激激活， 并且它们的放电频率对于不同刺激来说都是类似的。其余 59% 的细胞表现出一些选择性， 对复杂刺激的反应更活跃。 位置任务和物体任务位置任务的激活局限于右半球物体任务的激活则是双侧的 第八章 运动控制肌肉、运动神经元和脊髓α运动神经元α运动神经元起源于脊髓，通过脊髓腹根，终止于肌肉纤维。α运动神经元的动作电位使其释放神经递质，此处的神经递质是乙酰胆碱。神经递质的释放并不影响下游的神经元，而是使肌肉纤维收缩。因此，α运动神经元提供了将神经信号转化为机械运动的生理基础。当α运动神经元改变肌肉的长度和张力时， 运动就产生了 α神经元α运动神经元也接受脊髓下行纤维和脊髓各部分间的中间神经元的输入。下行纤维起源于一些皮质和皮质下结构，发出的信号可能是兴奋性的或抑制性的，是自主运动的基础。例如，激活二头肌的下行指令使肘关节弯曲，肘关节弯曲又使三头肌拉伸，如果不加抑制，拉伸反射会导致三头肌兴奋并移动肢体回到原先的位置。要产生运动，传递给一个主动肌的兴奋性信号总伴随着经由中间神经元传递至其拮抗肌的抑制性信号。 皮质下运动结构 小脑和基底神经节在运动控制中发挥关键作用的两个主要的皮质下结构： 小脑和基底神经节小脑是一个规模较大的结构， 接受大量的感觉输入，包括躯体感觉、前庭觉、视觉和听觉各通道的信息。它还接受许多皮质联合区域的纤维传入。小脑不直接将信息输出到其他部分，而是将信息传递至小脑深部的核团。 基底神经节 (basal ganglia) 是五个核团的总称。作为一个整体， 输入主要局限在组成纹状体的两个核团—尾状核和壳核内。输出几乎只通过苍白球的内侧部分和黑质的一部分。 场向量 场向量在运动发出之前即转向将要发出的运动的方向 脑机接口 BCI/BMI对运动皮质细胞做记录， 厘清每个神经元活动的特点并产生实时的场向量，一旦建立这这些表征，就可以利用场向量直接控制机器设备。 脑机接口系统原理 运动想象 第九章 学习与记忆学习与记忆的理论学习与记忆之间的关系是什么？ 简单地说， 学习 (learning) 是获取新信息的过程， 其结果便是记忆（memory)。学习与记忆可以假设为三个主要的阶段： 编码是对输入信息的处理与储存，它分为两个阶段 ：获取与巩固。 获取是对感觉通路和感觉分析阶段的输入信息进行登记，巩固是生成一个随时间的推移而增强的表征； 存储是获取和巩固的结果，代表了信息的长久记录； 提取是通过利用所储存的信息创建意识表征或执行习得的行为，如自动化动作。 感觉和短时记忆机制记忆包含了时间成分。 我们可以在短时间或长时间内记住很多事情，可以描述为“精神的时间旅行“。记忆的定义：我们能够在多长时间内保持感兴趣的信息。根据信息维持的时间长短， 可以将记忆分为： 感觉记忆 短时记忆 长时记忆 短时记忆容量 人类记忆的假想结构图 第十章 情绪六种基本情绪 情绪的维度 杏仁核 在通过恐惧性条件反射学习对厌恶的事件作出反应时， 杏仁核的作用被认为是内隐的。使用内隐这个术语是因为学习过程是通过行为或是生理反应（如自主神经系统的唤醒或潜在惊吓） 间接表达出来的。 恐惧性条件反射通路 句法启动效应 事件相关电位ERP演示句法启动效应 第十一章 语言脑与语言的关系（不完全正确） 第十二章 注意与意识注意分为两类有意的——有意注意作为一种自上而下的、目标驱动的影响，对应着我们有意地注意一些东西的能力反射性的——反射性注意作为一种自下而上的、刺激驱动的影响，则描述了这样一种现象，即一个感觉事件捕获了我们的注意。 这两种注意形式在性质上有所不同，在神经机制上也许亦有不同。 ERP描述注意效应通俗的解释是：注意力和刺激恰在同一区域时，事件相关电位的波幅会更大。 ERP描述返回抑制返回抑制：一个感觉事件与之后的一个目标刺激紧随出现在同一位置时，反射性线索效应就可能出现。在这种条件下，对被提示位置的反应时间短于对非提示位置的反应，但这种情况只在线索和目标刺激间的时间间隔较短&lt;250ms 的时候会出现；在时间间隔较长的情况下,这种效应会发生反转， 产生返回抑制。返回抑制可以这样子理解： 你在打地鼠，有一个洞总是有地鼠，地鼠出现的时间间隔较短，那你注意这个洞是有利的； 你在学习，然后打雷了。打雷出现的时间间隔较长，而且打雷是你学习的干扰，那你注意这个雷就是不好的。","categories":[],"tags":[{"name":"大学专业课","slug":"大学专业课","permalink":"http://glisses.github.io/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"GitHub博客常用指令","slug":"GitHub博客常用指令","date":"2021-06-24T07:32:36.000Z","updated":"2021-08-10T06:19:26.824Z","comments":true,"path":"2021/06/24/GitHub博客常用指令/","link":"","permalink":"http://glisses.github.io/2021/06/24/GitHub%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","excerpt":"Create a new post1$ hexo new \"My New Post\" 则会在source文件夹新建一个名为My New Post的md文件。","text":"Create a new post1$ hexo new \"My New Post\" 则会在source文件夹新建一个名为My New Post的md文件。 Generate static files1$ hexo g 即可更新 Run server1$ hexo s 即可在locaohost预览博客，以便修改。 Deploy to remote sites1$ hexo d 即可将更新内容部署到自己的GitHub博客上。 Add images to GitHub imgWarehouse第一步，在本地blog\\image\\ImageWarehouse保存图片。第二步，在ImageWarehouse文件夹内打开Git Bash。第三步， 123$ git add XXX.png$ git commit -am 对这张图的描述$ git push 第四步，在https://github.com/yourself/ImageWarehouse/tree/main/img 找到这张图，点击download，复制弹出页面的链接。该链接即为图片在GitHub上的外联地址。","categories":[],"tags":[{"name":"blog","slug":"blog","permalink":"http://glisses.github.io/tags/blog/"}]},{"title":"数据结构期末复习","slug":"数据结构期末复习","date":"2021-06-22T15:41:38.000Z","updated":"2021-06-25T04:26:01.454Z","comments":true,"path":"2021/06/22/数据结构期末复习/","link":"","permalink":"http://glisses.github.io/2021/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/","excerpt":"第1章 绪论基本概念 常用的数据结构包括__ 、_ 、_ 、___ 。（线性结构、树型结构、图状结构） 数据项是数据结构中讨论的最小单位。数据元素可以是数据项的集合。 数据元素是数据结构中讨论的基本单位。 数据结构是相互之间存在某种逻辑关系的数据元素的集合。 数据是计算机操作的对象的总称。 存储结构是逻辑结构在存储器（内存）中的映像。 数据关系的映像方法： 顺序映像，以相对的存储位置表示后继关系； 链式映像，以附加信息（指针）表示后继关系。 常用的逻辑结构包括、 、_ 、_ 。（集合结构、线性结构、树型结构、图状结构） 算法的设计取决于选定的_ ，算法的实现依赖于采用的__ 。（逻辑结构、存储结构） 数据类型是一个值的集合和定义在此集合的一组操作的总称。 抽象数据类型 Abstract Data Type （简称ADT）的描述方法：","text":"第1章 绪论基本概念 常用的数据结构包括__ 、_ 、_ 、___ 。（线性结构、树型结构、图状结构） 数据项是数据结构中讨论的最小单位。数据元素可以是数据项的集合。 数据元素是数据结构中讨论的基本单位。 数据结构是相互之间存在某种逻辑关系的数据元素的集合。 数据是计算机操作的对象的总称。 存储结构是逻辑结构在存储器（内存）中的映像。 数据关系的映像方法： 顺序映像，以相对的存储位置表示后继关系； 链式映像，以附加信息（指针）表示后继关系。 常用的逻辑结构包括、 、_ 、_ 。（集合结构、线性结构、树型结构、图状结构） 算法的设计取决于选定的_ ，算法的实现依赖于采用的__ 。（逻辑结构、存储结构） 数据类型是一个值的集合和定义在此集合的一组操作的总称。 抽象数据类型 Abstract Data Type （简称ADT）的描述方法： ADT 抽象数据类型名 { 数据对象：〈数据对象的定义〉 数据关系：〈数据关系的定义〉 基本操作：〈基本操作的定义〉 } ADT 抽象数据类型名 抽象数据类型（ADT）的两个重要特征： 数据抽象用ADT描述程序处理的实体时，强调的是其本质的特征、其所能完成的功能以及它和外部用户的接口（即外界使用它的方法）。 数据封装将实体的外部特性和其内部实现细节分离，并且对外部用户隐藏其内部实现细节。 抽象数据类型是指一个数学模型以及定义在此数学模型上的一组操作，包括__ 、 和_____ 三部份。（数据对象、数据关系、基本操作） 类C语言 类C语言是介于伪码和C语言之间，用来描述抽象数据类型和算法的工具。（1）预定义常量和类型#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE（不可行的） -1#define OVERFLOW（溢出） -2//Status是函数的类型，其值是函数结果状态代码typedef int Status （2）数据结构的表示用类型定义（typedef）描述，数据元素类型约定为ElemType，用户在使用时可以自行定义。 （3）算法的描述形式函数类型 函数名（函数参数表）{//算法说明语句序列}//函数名当函数返回值为函数结果状态码时，函数定义为Status类型。在形参表中，以&amp;打头的参数即为引用参数。 （4）赋值语句简单赋值 变量名 = 表达式；串联赋值 变量名1 = 变量名2 = ┅ = 变量名k = 表达式；成组赋值 （变量名1，┅，变量名k） = （表达式1，┅，表达式k）； 结构名1 = 结构名2； 结构名1 = （值1，┅，值k）； 变量名 [ ] =表达式； 变量名1 [ 起始下标 ┅ 终止下标] =变量名2 [ 起始下标 ┅ 终止下标] ；交换赋值 变量名1 ←→ 变量名2条件赋值 变量名 = 条件表达式 ？ 表达式 T：表达式 F （5）选择语句条件语句1 if（表达式） 语句；条件语句2 if（表达式） 语句； else 语句；开关语句1 switch { case 值1：语句序列1；break; ┅ case 值n：语句序列n；break; default : 语句序列n+1; }开关语句2 switch { case 条件1：语句序列1；break; ┅ case 条件n：语句序列n；break; default : 语句序列n+1; } （6）循环语句for语句 for（赋初值表达式序列；条件；修改表达式序列）语句；while语句 while（条件）语句；do-while语句 do { 语句序列； } while（条件）； （7）结束语句函数结束语句 return 表达式； return；case结束语句 break ;异常结束语句 exit(异常代码）； （8）输入和输出语句输入语句 scanf（变量1， ┅ ，变量n）；输出语句 printf（表达式1， ┅ ，表达式n）； （9）注释单行注释 // 文字序列； （10）逻辑运算与运算 &amp;&amp;： 对于A&amp;&amp;B，当A的值为0时，不再对B求值；或运算∥ ： 对于A∥B，当A的值为非0时，不再对B求值； 11）基本函数求最大值 max（表达式1， ┅ ，表达式n ）；求最小值 min（表达式1， ┅ ，表达式n ）；求绝对值 abs（表达式）；求不足整数值 floor（表达式）；求进位整数值 ceil（表达式）；判定文件结束 eof（文件变量）或 eof；判定行结束 eoln（文件变量）或 eoln； 例题 类C语言中的Status表示函数的_ ，其值是函数结果的_ 。 (类型、状态代码) 算法 算法必须满足五个重要特性：有穷性，确定性，可行性，有输入，有输出。有穷性：不会死循环； 确定性：在每种情况下，都有唯一的执行路径； 可行性：操作都是基本的； 有输入：输入被嵌入算法中也算有输入； 有输出：略。 设计算法时要考虑：正确性、可读性、健壮性、高效率和低存储量的要求。 算法的时间复杂度举例：x=n;y=0;While (x&gt;=(y+1)*(y+1)) y=y+1;基本操作: 加法操作；时间复杂度为O(n1/2) 求时间复杂度，是求最坏情况下的。 算法时间取决于控制结构和原操作的综合效果。 算法的空间复杂度算法的存储分析 若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除 输入和程序之外的辅助变量所占额外空间。 所需额外空间相对于输入数据量来说是常数，则称此算法为原地工作。 若所需存储量依赖于特定的输入，则通常按最坏情况考虑。举例 1234567Void bubble_sort (int a[ ],int n)&#123; for (i=n-1,change=TRUE; i&gt;=1 &amp;&amp; change; --i)&#123; change=FALSE; for (j=0; j&lt;i; ++j) if (a[j]&gt;a[j+1]) &#123;a[j] ←→a[j+1]; change=TRUE;&#125; &#125; &#125; 算法的空间复杂度为O（n），即输入的a[]； 算法的辅助存储空间为O（1），即i,j,change。不考虑常数。 第2章 线性表线性表线性表是一种最简单的线性结构，线性表的抽象数据类型定义如下：ADT List {数据对象： D＝{ ai | ai ∈ElemSet, i=1,2,…,n, n≥0 } {称 n 为线性表的表长; 称 n=0 时的线性表为空表。}数据关系： R1＝{ &lt;ai-1 ,ai &gt;|ai-1 ,ai∈D, i=2,…,n } {设线性表为 (a1，a2, . . . ，ai，. . . ，an), 称 i 为 ai 在线性表中的位序。} 将线性表置为空表，不同于销毁这个线性表。 线性表的起始地址，称作线性表的基地址 线性表的顺序存储结构123456789// 顺序映像的类C语言描述#define LIST_INIT_SIZE 100 // 线性表存储空间的初始分配量#define LISTINCREMENT 10 // 线性表存储空间的分配增量typedef struct &#123; ElemType *elem; // 存储空间基址 int length; // 当前长度 int listsize; // 当前分配的存储容量&#125; SqList; // 称为 顺序表 12345678// 顺序表的初始化Status InitList_Sq( SqList &amp;L ) &#123; // 构造一个空的线性表 L.elem = (ElemType*) malloc (LIST_INIT_SIZE*sizeof (ElemType));if (!L.elem) exit(OVERFLOW);L.length = 0;L.listsize = LIST_INIT_SIZE;return OK;&#125; // InitList_Sq 12345678910// 顺序表的查找int LocateElem_Sq(SqList L, ElemType e, Status (*compare)(ElemType, ElemType))&#123; // 在顺序表中查询第一个满足判定条件的数据元素， // 若存在，则返回它的位序，否则返回 0 i = 1; // i 的初值为第 1 元素的位序 p = L.elem; // p 的初值为第 1 元素的存储位置 while (i &lt;= L.length &amp;&amp; !(*compare)(*p++, e)) ++i; if (i &lt;= L.length) return i; else return 0;&#125; // LocateElem_Sq 背诵malloc函数的使用 1L.elem = (int*) malloc (LIST_INIT_SIZE * sizeof (int)); 引用顺序表中的变量： 第一个元素a1 L-&gt;elem[0] 第 i 个元素ai L-&gt;elem[i-1] 第 n 个元素an L-&gt;elem[n-1] 或者 L-&gt;elem[L-&gt;length-1] 12345678910111213141516Status ListInsert_Sq(SqList &amp;L, int i, ElemType e) &#123; // 在顺序表L的第 i 个元素之前插入新的元素e,1≤i≤L.length+1 if (i &lt; 1 || i &gt; L.length+1) return ERROR; // 插入位置不合法 if (L.length &gt;= L.listsize) &#123; // 当前存储空间已满，增加分配 newbase = (ElemType *)realloc(L.elem, (L.listsize+LISTINCREMENT)*sizeof (ElemType)); if (!newbase) exit(OVERFLOW); // 存储分配失败 L.elem = newbase; // 新基址 L.listsize += LISTINCREMENT; // 增加存储容量 &#125; q = &amp;(L.elem[i-1]); // q 指示插入位置 for (p = &amp;(L.elem[L.length-1]); p &gt;= q; --p) *(p+1) = *p; // 插入位置及之后的元素右移 *q = e; // 插入e ++L.length; // 表长增1 return OK;&#125; // ListInsert_Sq 注意上面使用的是realloc(从哪里开始重新分配，分配多少);在顺序表中，指针p所指向的元素后移一位如何用C语言程序表示？ *(p+1) = *p; 12345678910Status ListDelete_Sq(SqList &amp;L, int i, ElemType &amp;e) &#123; if ((i &lt; 1) || (i &gt; L.length)) return ERROR; // 删除位置不合法 p = &amp;(L.elem[i-1]); // p 为被删除元素的位置 e = *p; // 被删除元素的值赋给 e q = L.elem+L.length-1; // 表尾元素的位置 for (++p; p &lt;= q; ++p) *(p-1) = *p; // 被删除元素之后的元素左移 --L.length; // 表长减1 return OK;&#125; // ListDelete_Sq 指针q指向顺序表（表长为n)的表尾元素如何用C语言程序表示？ q = &amp;(L.elem[n-1]); 或 q = L.elem+L.length-1; 单链表为了操作方便，常在第一个结点之前虚加一个“头结点”，以指向头结点的指针为链表的头指针。 123456789101112// 结点和单链表的类 C 语言描述Typedef struct LNode &#123; ElemType data; // 数据域 struct Lnode *next; // 指针域 &#125; LNode, *LinkList; LinkList L； // L 为单链表的头指针typedef struct &#123; // 链表类型 Link head, tail; // 分别指向头结点和最后一个结点的指针 int len; // 指示链表长度 Link current; // 指向当前被访问的结点的指针，初始位置指向头结点&#125; LinkList; 例题画出一个有三个元素的单链表的结构。 12345678910111213141516171819202122// 单链表的插入void LinkListInsert(LinkList L,int i,int x) //在线性表的第i个元素前插入新的元素x&#123; LNode *p,*s; int n; p=L; //p指向头结点，n为计数器 n=0; while(p&amp;&amp;n&lt;i-1) //沿指针向后查找，直到p指向第i-1个元素或p为空 &#123; p=p-&gt;next; n++; &#125; if(!p||n&gt;i-1) // i大于表长或者小于1则退出程序 &#123; printf(\"第%d个元素不存在!\\n\",i); exit(1); &#125; s=(LinkList)malloc(sizeof(LNode)); //插入新的元素 s-&gt;data=x; s-&gt;next=p-&gt;next; p-&gt;next=s;&#125; 12345678910111213141516171819202122// 单链表的删除void LinkListDelete(LinkList L,int i) //删除线性表的第i个元素&#123; LNode *p,*s; int n; p=L; //p指向头结点，n为计数器 n=0; while(p&amp;&amp;n&lt;i-1) //沿指针向后查找，直到p指向第i-1个元素或p为空 &#123; p=p-&gt;next; n++; &#125; if(!p||n&gt;i-1||p-&gt;next==NULL) // i大于表长或者小于1则退出程序 &#123; printf(\"第%d个元素不存在!\\n\",i); exit(1); &#125; s=p-&gt;next; //删除第i个元素 p-&gt;next=s-&gt;next; printf(\"删除的元素为%d\\n\",s-&gt;data); free(s);&#125; 记住要free掉被删除的空间。 单循环链表单循环链表最后一个结点的指针域的指针又指回头结点的链表。它和单链表的差别仅在于，判别链表中最后一个结点的条件不再是“后继是否为空”，而是“后继是否为头结点”。 例题：单循环链表逆置1234567891011121314// 类c语言Status Contray_Cirl (LinkList &amp;L) &#123; t=L; //t指向单循环链表的头结点 p=t-&gt;next; //p指向单循环链表的第一个结点 q=p-&gt;next; //q指向单循环链表的第二个结点 While (p!=L) &#123; p-&gt;next=t; //让p结点next域指针指向其前驱 t=p; //顺链向后移动指针t p=q; //顺链向后移动指针p q=p-&gt;next; //顺链向后移动指针q &#125; L-&gt;next=t; //让L的next域指针指向新链表的第一个结点 return OK;&#125; // Contray_Cirl 例题：约瑟夫环1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*约瑟夫环问题 Josephus：编号为1，2，3，…，n的n个人按顺时针方向围坐一圈，任选一个正整数作为报数上限m（其中m&lt;n）。从第一个人开始按顺时针方向自1开始顺序报数，报到m时停止报数。报m的人出列，从他在顺时针方向上的下一个人重新从1报数，如此下去，直至所有人全部出列。*/#include &lt;bits/stdc++.h&gt;using namespace std;#define ufor(i,l,r) for (int i=l;i&lt;=r;i++)typedef struct node&#123; int data; struct node *next;&#125; Lnode, *LinkList; //线性表 //表尾插入结点构造指定长度的单向循环链表void CreatList(LinkList L, int n)&#123; int i; Lnode *p,*s; p=L; //表尾 ufor (i,1,n-1) &#123; s=(LinkList) malloc(sizeof(Lnode)); s-&gt;data = i+1; s-&gt;next = p-&gt;next; p-&gt;next = s; p=s; //p往后移 &#125; &#125;void printList(LinkList L, int n)&#123; Lnode *p=L; int i; ufor (i,0,n-1) &#123; printf(\"%d \",p-&gt;data); p = p-&gt;next; &#125;&#125;//依次删除线性表的第m个元素void LinkListDelete(LinkList L, int n, int m)&#123; Lnode *p,*s; int i,j; p=L; ufor (i,0,n-1) &#123; j=1; while (j&lt;m-1) p=p-&gt;next, j++; s = p-&gt;next; //要被删除的结点 p-&gt;next = s-&gt;next; printf(\"%d \",s-&gt;data); free(s); p = p-&gt;next; &#125;&#125; int main()&#123; LinkList L; int m,n; L=(LinkList) malloc(sizeof(Lnode)); L-&gt;data = 1; L-&gt;next = L; //最后一个结点的指针指向头 printf(\"请输入初始人数:\\n\"); scanf(\"%d\",&amp;n); CreatList(L,n); printf(\"\\n参与游戏人员编号分别为：\\n\"); printList(L,n); printf(\"\\n\"); printf(\"\\n请输入报数上限：\\n\"); scanf(\"%d\",&amp;m); printf(\"\\n依次出列的人员编号为：\\n\"); LinkListDelete(L,n,m); printf(\"\\n\"); return 0;&#125; 双向链表结构： 12345typedef struct DuLNode &#123; ElemType data; // 数据域 struct DuLNode *prior; // 指向前驱的指针域 struct DuLNode *next; // 指向后继的指针域&#125; DuLNode, *DuLinkList; 1234567891011121314151617181920212223// 双向链表的插入void LinkListInsert(DuLinkList L,int i,int x) //在双向链表的第i个元素前插入新的元素x&#123; LNode *p,*s; int n; p=L; //p指向第一个结点，n为计数器 n=0; while(p&amp;&amp;n&lt;i-1) //沿指针向后查找，直到p指向第i-1个元素或p为空 &#123; p=p-&gt;next; n++; &#125; if(!p||n&gt;i-1) // !p则i大于表长； n&gt;i-1则i&lt;1 &#123; printf(\"第%d个元素不存在!\\n\",i); exit(1); &#125; s=(DuLinkList)malloc(sizeof(LNode)); //插入新的元素 s-&gt;data=x; s-&gt;next=p-&gt;next; s-&gt;prior=p; p-&gt;next=s; if(s-&gt;next) s-&gt;next-&gt;prior=s;&#125; //LinkListInsert 1234567891011121314151617181920212223// 双向链表的删除void LinkListInsert(DuLinkList L,int i,int x) //在双向链表中删除第i个元素&#123; LNode *p,*s; int n; p=L; //p指向第一个结点，n为计数器 n=0; while(p&amp;&amp;n&lt;i-1) //沿指针向后查找，直到p指向第i-1个元素或p为空 &#123; p=p-&gt;next; n++; &#125; if(!p||n&gt;i-1||p-&gt;next==NULL) // i大于表长或者小于1则退出程序 &#123; printf(\"第%d个元素不存在!\\n\",i); exit(1); &#125; s=p-&gt;next; //删除第i个元素 printf(\"删除的元素为%d\\n\",s-&gt;data); p-&gt;next=s-&gt;next; if(s-&gt;next) s-&gt;next-&gt;prior=p; free(s);&#125; 注意 if(!p||n&gt;i-1|| p-&gt;next==NULL) 有可能这个数要删，但是没必要/dog if(s-&gt;next) s-&gt;next-&gt;prior=p; 这也是很容易忘记的啊，得s有后继，才改后继的前驱。 第3章 栈和队列栈栈的抽象数据类型定义： 1234567891011121314151617ADT Stack &#123; 数据对象： D＝&#123; ai | ai ∈ElemSet, i=1,2,...,n, n≥0 &#125; 数据关系： R1＝&#123; &lt;ai-1, ai &gt;| ai-1, ai∈D, i=2,...,n &#125; 约定an 端为栈顶，a1 端为栈底。 基本操作： InitStack(&amp;S) DestroyStack(&amp;S) StackLength(S) StackEmpty(s) GetTop(S, &amp;e) ClearStack(&amp;S) Push(&amp;S, e) Pop(&amp;S, &amp;e) StackTravers(S, visit())&#125;ADT Stack 12345678// 栈的顺序存储表示 #define STACK_INIT_SIZE 100; #define STACKINCREMENT 10; typedef struct &#123; SElemType *base; //基底 SElemType *top; //栈顶 int stacksize; &#125; SqStack; 123456789101112//顺序栈的插入Status Push (SqStack &amp;S, SElemType e) &#123; if (S.top - S.base &gt;= S.stacksize) &#123;//栈满，追加存储空间 S.base = (ElemType *) realloc ( S.base, (S.stacksize + STACKINCREMENT) * sizeof (ElemType)); if (!S.base) exit (OVERFLOW); //存储分配失败 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *S.top++ = e; return OK;&#125; 注意 上面这段程序，主要是注意realloc和S.top的赋值 顺序栈满的判断： S.top &gt;= S.base+S.stacksize 顺序栈空的判断: S.top == S.base 123456789// 顺序栈的删除Status Pop (SqStack &amp;S, SElemType &amp;e) &#123; // 若栈不空，则删除S的栈顶元素， // 用e返回其值，并返回OK； // 否则返回ERROR if (S.top == S.base) return ERROR; e = *--S.top; return OK;&#125; 例题：用顺序栈实现数值转换123456789101112void conversion ( ) &#123; //数制转换的算法 InitStack(S); scanf (\"%d\",N); while (N) &#123; Push(S, N % 8); N = N/8; &#125; while (!StackEmpty(S)) &#123; Pop(S,e); printf ( \"%d\", e ); &#125;&#125; // conversion 队列队列的抽象数据类型定义： 123456789101112 ADT Queue &#123; 数据对象： D＝&#123;ai | ai∈ElemSet, i=1,2,...,n, n≥0&#125; 数据关系： R1＝&#123; &lt;a i-1,ai &gt; | ai-1, ai ∈D, i=2,...,n&#125; //约定其中a1 端为队列头， an 端为队列尾 基本操作： InitQueue(&amp;Q) DestroyQueue(&amp;Q) QueueEmpty(Q) QueueLength(Q) GetHead(Q, &amp;e) ClearQueue(&amp;Q) EnQueue(&amp;Q, e) DeQueue(&amp;Q, &amp;e) QueueTravers(Q, visit())&#125; ADT Queue 注意 对于一个队列，出队序列必然等于入队序列。 栈和队列的共同点：只允许在端点处插入和删除元素。 链队列12345678910//链队列的结构定义typedef struct QNode &#123; // 结点类型 QElemType data; struct QNode *next;&#125; QNode, *QueuePtr;typedef struct &#123; // 链队列类型 QueuePtr front; // 队头指针 QueuePtr rear; // 队尾指针&#125; LinkQueue; 链队列判空：Q.front == Q.rear 123456789//链队列的插入Status EnQueue (LinkQueue &amp;Q, QElemType e) &#123; // 插入元素e为Q的新的队尾元素 p = (QueuePtr) malloc (sizeof (QNode)); if (!p) exit (OVERFLOW); //存储分配失败 p-&gt;data = e; p-&gt;next = NULL; Q.rear-&gt;next = p; Q.rear = p; return OK;&#125; 12345678910//链队列的删除Status DeQueue (LinkQueue &amp;Q, QElemType &amp;e) &#123; // 若队列不空，则删除Q的队头元素， //用 e 返回其值，并返回OK；否则返回ERROR if (Q.front == Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; if (Q.rear == p) Q.rear = Q.front; free (p); return OK;&#125; 循环队列就是，队尾的下一个是队头，的队列。相当于一个圈。顺序队列的结构定义： 123456#define MAXQSIZE 100 //最大队列长度 typedef struct &#123; QElemType *base; // 动态分配存储空间 int front; // 头指针，若队列不空，指向队列头元素 int rear; // 尾指针，若队列不空，指向队列尾元素的下一个位置 &#125; SqQueue; 12345678// 循环队列的插入Status EnQueue (SqQueue &amp;Q, ElemType e) &#123; // 插入元素e为Q的新的队尾元素 if ((Q.rear+1) % MAXQSIZE == Q.front) return ERROR; //队列满 Q.base[Q.rear] = e; Q.rear = (Q.rear+1) % MAXQSIZE; return OK;&#125; 注意 Q.rear = (Q.rear+1) % MAXQSIZE; 可以很好地执行循环队列，队尾的后移。 12345678//循环队列的删除Status DeQueue (SqQueue &amp;Q, ElemType &amp;e) &#123; // 若队列不空，则删除Q的队头元素， // 用e返回其值，并返回OK; 否则返回ERROR if (Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front+1) % MAXQSIZE; return OK;&#125; 注意 Q.front = (Q.front+1) % MAXQSIZE; 可以很好地执行循环队列，队首的后移。 12345//求队列长度int QueueLength (SqQueue Q) &#123; // 返回Q的元素个数， // 即队列的长度 return (Q.rear – Q.front + MAXQSIZE) % MAXQSIZE;&#125; 第4章 串串是和线性表很相似的数据结构。不过串的数据对象约束为字符集，而且串通常以串的整体作为操作对象 串的抽象数据类型 1234567891011121314ADT String &#123;数据对象： D＝&#123; ai |ai∈CharacterSet , i=1,2,...,n, n≥0 &#125;数据关系： R1＝&#123; &lt; ai-1, ai &gt; | ai-1, ai ∈D , i=2,...,n &#125;基本操作： StrAssign (&amp;T, chars) DestroyString(&amp;S) StrCopy (&amp;T, S) StrLength(S) StrCompare (S, T) Concat (&amp;T, S1, S2) StrEmpty (S) SubString (&amp;Sub, S, pos, len) ClearString (&amp;S) Index (S, T, pos) Replace (&amp;S, T, V) StrInsert (&amp;S, pos, T) StrDelete (&amp;S, pos, len)&#125; ADT String 例题 空串的长度为零（我猜的）期末考会涉及串的几个操作： StrAssign (&amp;T, chars)初始条件：chars 是字符串常量。操作结果：把 chars 赋为 T 的值。 StrCopy (&amp;T, S)初始条件：串 S 存在。操作结果：由串 S 复制得串 T。 StrEmpty(S) 初始条件：串S存在。 操作结果：若 S 为空串，则返回TRUE，否则返回 FALSE。 StrCompare(S,T) 初始条件：串 S 和 T 存在。 操作结果：若S &gt; T，则返回值 &gt; 0； 若S == T，则返回值 = 0； 若S &lt; T，则返回值 &lt; 0 。例如：StrCompare(‘data’, ‘state’) &lt; 0StrCompare(&apos;cat&apos;, &apos;case&apos;) &gt; 0 StrLength(S) 初始条件：串 S 存在。 操作结果：返回 S 的元素个数， 称为串的长度。 Concat(&amp;T,S1,S2) 初始条件：串 S1 和 S2 存在。 操作结果：用 T 返回由 S1 和 S2联接而成的新串。例如： Concat( T, ‘man’, ‘kind’)求得 T = &apos;mankind&apos; SubString (&amp;Sub, S, pos, len) 初始条件： 串 S 存在，1≤pos≤StrLength(S)，且0≤len≤StrLength(S)-pos+1。 操作结果： 用 Sub 返回串 S 的第 pos 个字符起长度为 len 的子串，子串为“串” 中的一个字符子序列例如：SubString(&amp;Sub, ‘hello’,2,3), 得Sub=’ell’ Index (S, T, pos) 初始条件：串S和T存在，T是非空串，1≤pos≤StrLength(S)。 操作结果： 若主串 S 中存在和串 T 值相同的子串, 则返回它在主串 S 中第pos个字符之后第一次出现的位置；否则函数值为0。（ “子串在主串中的位置”意指子串中的第一个字符在主串中的位序。） 假设 S = ‘abcaabcaaabc’, T = ‘bca’ Index(S, T, 1) = 2； Index(S, T, 3) = 6； Index(S, T, 8) = 0 。例题若串S1=‘ABCDEFG’,S2= 1223’,S3=‘###’,执行Substring(&amp;Sub, S1, Strlength(S3) ,Index(S2, ‘2’,1))，即为求SubString(&amp;Sub, ‘ABCDEFG’, 3, 2), 则Sub= ‘CD’。 注意串超过限定长度的话，要截断，即舍去后面的部分 串的模式匹配-一般算法1234567891011int Index(SString S, SString T, int pos) &#123; // 返回子串T在主串S中第pos个字符之后的位置。若不存在， // 则函数值为0。其中，T非空，1≤pos≤StrLength(S)。 i = pos; j = 1; while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; if (S[i] == T[j]) &#123; ++i; ++j; &#125; // 继续比较后继字符 else &#123; i = i-j+2; j = 1; &#125; // 指针后退重新开始匹配 &#125; if (j &gt; T[0]) return i-T[0]; else return 0;&#125; // Index 一般算法的最坏时间复杂度是O(StrLength(S) * StrLength(T)) 串的模式匹配-KMP(D.E.Knuth, V.R.Pratt, J.H.Morris) 算法KMP的基本思想：在匹配过程中，当 S[i] &lt;&gt; T[j] 时，已经得到的结果： S[i-j+1..i-1] == T[1..j-1] 若已知 T[1..k-1] == T[j-k+1..j-1] 则有 S[i-k+1..i-1] == T[1..k-1] KMP算法的时间复杂度可以达到O(m+n) next数组的求法下面的图有点歧义。“向左向右扩展”不是说扩展的过程中，两个框保持相同；而是扩展到两个框相同的最长（且不重合）的地方。 nextval数组的求法nextval[1]肯定是0。然后i从2开始，nextval[i]=(a[i]==a[next[i])? nextval[next[i]] : next[i]; 例题求模式串T=‘abaababcaabbabaabac’的next和nextval：next 0112234312231234567nextval 0102104302130102107 第5章 数组和广义表数组的抽象数据类型： 12345678910ADT Array &#123; 数据对象： D＝&#123;aj1,j2, ..., jn| ji =0,...,bi -1, i=1,2,..,n, n(&gt;0)是数组的维数，bi 是数组第i 维的长度&#125; 数据关系： R＝&#123;R1, R2, ..., Rn&#125; Ri＝&#123;&lt;aj1,... ji,... jn , aj1, ...ji +1, ...jn &gt; | 0  jk  bk -1, 1  k  n 且k  i, 0  ji  bi -2, i=2,...,n &#125; 基本操作: InitArray（）, DestroyArray（）, Value（）, Assign（）&#125; ADT Array 数组是什么，懂得都懂，就不赘述啦~ 二维数组按行序/列序为主存放设有个3*3的数组。 按行序存放即为： a0,0 a0,1 a0,2 a1,0 a1,1 a1,2 a2,0 a2,1 a2,2 按列序存放即为： a0,0 a1,0 a2,0 a0,1 a1,1 a2,1 a0,2 a1,2 a2,2例题设有数组A[i,j]，数组的每个元素长度为3字节，i的值为1到8，j的值为1到10，数组从内存首地址BA开始顺序存放，当用以列为主存放时，元素A[5，8]的存储首地址为( B )。A．BA+141 B．BA+180 C．BA+222 D．BA+225【解析】以列为主，则 首地址 = 基地址 + （前面有几列每行几个数 + 这一列之前放了几个数）每个元素占几个字节所以A[5,8]的存储首地址 = BA + （78 + 5-1）3 = BA+180 稀疏矩阵假设 m 行 n 列的矩阵含 t 个非零元素，则称σ = t/(m*n) 为稀疏因子，通常认为 σ&lt;=0.05 的矩阵为稀疏矩阵。 1) 特殊矩阵 非零元在矩阵中的分布有一定规则 例如: 三角矩阵 对称矩阵 对角矩阵2) 随机稀疏矩阵 非零元在矩阵中随机出现 例题 有一N阶对称矩阵，矩阵元为Aij,将其下三角部分以行序为主序存放在一维数组M[0,n(n+1)/2-1]中，设矩阵最左上角矩阵元为A00，则M[31]对应的矩阵元为（D）。 A. A2,6 B. A7,3 C. A3,7 D. A7,3和A3,7【解析】这题的trick在于，因为是对称的，所以如果M[31]对应A3,7 ,则必定也对应A7,3 设有一个10阶的对称矩阵A，采用压缩存储方式，以行序为主存储，a11为第一元素，其存储地址为1，每个元素占一个地址空间，则a85的地址为（ B ）。 A. 13 B. 33 C. 18 D. 40【解析】i(i-1)/2+j = 87/2+5 = 33注意“地址”和“存储的首地址”是俩概念 三维数组a[4][3][2] (下标从0开始)，假设a[0][0][0] 的地址为50，数据以行序有限方式存储，每个元素的长度为2字节，则a[2][1][1]的地址是___.(80)【解析】50+（2* 3* 2 +2 +1）*2 = 80 稀疏矩阵的转置存储结构： 12345678910//三元组顺序表 #define MAXSIZE 12500 typedef struct &#123; int i, j; //该非零元的行下标和列下标 ElemType e; // 该非零元的值 &#125; Triple; // 三元组类型typedef union &#123; Triple data[MAXSIZE + 1]; int mu, nu, tu; &#125; TSMatrix; // 稀疏矩阵类型 快速转置算法： 123456789101112Status FastTransposeSMatrix(TSMatrix M, TSMatrix &amp;T)&#123; T.mu = M.nu; T.nu = M.mu; T.tu = M.tu; if (T.tu) &#123; for (col=1; col&lt;=M.nu; ++col) num[col] = 0; for (t=1; t&lt;=M.tu; ++t) ++num[M.data[t].j]; cpot[1] = 1; for (col=2; col&lt;=M.nu; ++col) cpot[col] = cpot[col-1] + num[col-1]; for (p=1; p&lt;=M.tu; ++p) &#123;转置矩阵元素&#125; &#125; // if return OK;&#125; // FastTransposeSMatrix 思想类似基数排序。上面的代码看起来没有排序，但实际上可以保证转置后三元组的有序性。因为在转置之前，三元组保证了以行为第一关键字，列为第二关键字的有序性。所以我们按顺序扫一遍，把它们放进堆里，列相同的，它们的行数依然有序。 广义表广义表的抽象数据结构： 123456ADT Glist &#123; 数据对象：D＝&#123;ei | i=1,2,..,n; n≥0; ei∈AtomSet 或 ei∈GList, AtomSet为某个数据对象 &#125; 数据关系： LR＝&#123;&lt;ei-1, ei &gt;| ei-1 ,ei∈D, 2≤i≤n&#125; 广义表的长度定义为最外层包含元素个数；广义表的深度定义为所含括弧的重数；（注意：“原子”的深度为 0 ，空表”的深度为 1 ） 任何一个非空广义表 LS = ( a1, a2, …, an) 均可分解为表头 Head(LS) = a1 和 表尾 Tail(LS) = ( a2, …, an) 两部分。 例如: D = ( E, F ) = ((a, (b, c))，F )Head( D ) = E, Tail( D ) = ( F )Head( E ) = a, Tail( E ) = ( ( b, c) )Head( (( b, c)) ) = ( b, c), Tail( (( b, c)) ) = ( )Head( ( b, c) ) = b, Tail( ( b, c) ) = ( c )Head( ( c ) ) = c, Tail( ( c ) ) = ( ) 例题（1）广义表（（a,b,c,d））的表头是（ C ），表尾是（ B ）。 A. a B.（） C.（a,b,c,d） D.（b,c,d） （2）下面说法不正确的是( A )。 A. 广义表的表头总是一个广义表 B. 广义表的表尾总是一个广义表 C. 广义表难以用顺序存储结构 D. 广义表可以是一个多层次的结构 （3）当广义表中的每个元素都是原子时，广义表便成了__ 。（线性表） （4）广义表的表尾是指除第一个元素之外， 。（其余元素组成的表） （5）设广义表L=（（a,b,c）），则L的长度和深度分别为（ C ）。 A. 1和1 B. 1和3 C. 1和2 D. 2和3 （6）已知广义表 LS=((a,b), (c,d,e,f), g)， head 和 tail 分别是求表头和表尾，则tail( tail( head( tail(LS)))) 的运算结果是_____ 。 【解析】 tail( tail( head( tail(LS)))) = tail( tail( head( ((c,d,e,f),g) ) = tail( tail( (c,d,e,f) ) = tail( (d,e,f) ) = (e,f) 规律就是，做tail()时要补上一对括号，做head()时则不用。 广义表怎么画 由刚刚划分表头、表位的思想，结合上图中原子、非空表的画法，我们可以知道广义表的画法是怎样的。具体看下图的典型例题。 广义表的递归操作思想就是，把广义表分为表头表尾，分别操作，这样就可以递归了。 第6章 树和二叉树树树的基本术语结点:数据元素+若干指向子树的分支。结点的度:分支的个数。所以叶子节点的度是0。树的度:树中所有结点的度的最大值。叶子结点:度为零的结点。分支结点:度大于零的结点。结点的层次:假设根结点的层次为1，第l 层的结点的子树根结点的层次为l+1。树的深度： 树中叶子结点所在的最大层次。孩子结点和双亲结点对应；兄弟结点互为兄弟；祖先结点和子孙结点对应。一个点的祖先结点，是从它到根节点的路径上经过的除本身外所有点。内部结点：不是叶子也不是根的结点。 有向树：(１) 有确定的根；(２) 树根和子树根之间为有向关系。有序树： 子树之间存在确定的次序关系。无序树： 子树之间不存在确定的次序关系。 森林： 是m（m≥0）棵互不相交的树的集合。任何一棵非空树是一个二元组:Tree = （root，F）其中：root 被称为根结点，F 被称为子树森林。 n0表示度为0的点的个数，ni表示度为i的点的个数，n表示点的个数。 树的两个操作LeftChild(T, cur_e) // 求当前结点的最左孩子RightSibling(T, cur_e) // 求当前结点的右兄弟 sibling 英[ˈsɪblɪŋ] 美[ˈsɪblɪŋ]n. 兄; 弟; 姐; 妹; 恶心例题 树一定有唯一的根结点。（×，可以是空树） 从J结点到结点H的路径包括：结点J、G、D、H和分支JG、GD、DH。（要在意分支分支分支） 树中每个结点有唯一的双亲结点。(×，根结点除外) 二叉树二叉树是有序树。 二叉树的性质 在二叉树的第 i 层上至多有2^(i-1) 个结点 (i≥1) 。 深度为 i 的二叉树上至多含 2^i -1 个结点（i≥1）。 对任意二叉树，n0 = n2+1。 如果在[1,n]，则i/2向下取整 是i的双亲结点；2i 是i的左孩子结点；2i+1 是i的右孩子结点。 满二叉树深度为i，含2^i -1个结点的， 挤得满满当当的二叉树是也~ 完全二叉树定义：人话：满二叉树，按照层次遍历的逆序，非常严谨地删点。这个过程能到达的树，都是完全二叉树。严谨：树中所含的 n 个结点和满二叉树中编号为 1 至 n 的结点相对应。 性质：具有 n 个结点的完全二叉树的深度为 ┗（log2 n）┛ +1 。 例题 在完全二叉树中，结点总数为n为999，求叶子结点数n0为多少？【解析】n=999, 推出完全二叉树深度为┗ log2 999┛+1=10 ；前9层共有结点数29-1=511，第10层有999-511=488个结点（叶子结点）；488个叶子结点对应第9层244个度为2的结点，第9层共有29-1=256个结点，第9层的叶子结点数为256-244=12；叶子结点数n0=488+12=500。这里的，第九层叶子节点是很容易被漏掉的。 在完全二叉树中，结点总数为n，求叶子结点数n0为多少？（要求n0仅用n 来表示） n0 = n2 +1 n = n0+ n1+ n2 = 2 n0+ n1 – 1 n0 = ( n - n1+1)/2 完全二叉树中n1只能为1或0 当n1为1时，n只能是偶数，n0 = n/2 当n1为0时，n只能是奇数，n0 =( n+1)/2 所以： n0 =┗ (n+1)/2┛ 二叉树的存储表示顺序存储： 123#define MAX_TREE_SIZE 100typedef TElemType SqBiTree[MAX_TREE_SIZE];SqBiTree bt; 就是个一维数组，点在满二叉树的下标，就是它在数组中存储的下标。root下标为0。 二叉链表存储： 1234typedef struct BiTNode&#123; TElemType data; struct BiTnode *lchild, *rchild;&#125; BiTNode, *BiTree; 两个指针分别指向左孩子、右孩子。 三叉链表存储： 12345typedef struct TriTNode &#123; // 结点结构 TElemType data; struct TriTNode *lchild, *rchild; // 左右孩子指针 struct TriTNode *parent; //双亲指针 &#125; TriTNode, *TriTree; 三叉链表就是：比二叉链表存储多了个双亲指针。 双亲链表存储： 12345678910typedef struct BPTNode &#123; // 结点结构 TElemType data; int *parent; // 指向双亲的指针 char LRTag; // 左、右孩子标志域 &#125; BPTNode typedef struct BPTree&#123; // 树结构 BPTNode nodes[MAX_TREE_SIZE]; int num_node; // 结点数目 int root; // 根结点的位置 &#125; BPTree; 双亲链表存储方式下，一个结点包含：data、双亲指针、它是左孩子还是右孩子的tag。 例题1、如果二叉树用二叉链表表示，有多少个空链域？ 答：二叉树的空链域为2n0+n1=n0+n0+n1=n2+1+n0+n1=n+12、如果二叉树用三叉链表表示，有多少个空链域？ 答：每个结点的双亲指针都不空，但根结点的双亲指针为空，所以有n+2个空链域。3、二叉树不能用顺序结构来存储。(×) 森林双亲链表存储 12345678910#define MAX_TREE_SIZE 100typedef struct PTNode &#123; //结点结构 Elem data; int parent; // 双亲位置域 &#125; PTNode; typedef struct &#123; //树结构 PTNode nodes[MAX_TREE_SIZE]; int r, n; // 根结点的位置和结点个数 &#125; PTree; 孩子链表存储 12345678910111213typedef struct CTNode &#123; // 孩子结点结构 int child; struct CTNode *next; &#125; *ChildPtr;typedef struct &#123; // 双亲结点结构 Elem data; int parent; // 双亲位置域 ChildPtr firstchild; // 孩子链的头指针 &#125; CTBox;typedef struct &#123; // 树结构 CTBox nodes[MAX_TREE_SIZE]; int n, r; // 结点数和根结点的位置 &#125; CTree; 左孩子右兄弟链表存储 1234typedef struct CSNode&#123; Elem data; struct CSNode *firstchild, *nextsibling;&#125; CSNode, *CSTree; 由森林转换成二叉树根据左孩子有兄弟规则；互不相交的树之间的根看作兄弟。 也可以反过来，考把二叉树转坏成对应的森林。 二叉树的遍历先序：根左右；中序：左根右；后序：左右根。 先序： -+ab-cd/ef中序： a+b*c-d-e/f后序： abcd-+ef/- 中序遍历算法的非递归描述 123456789101112Status InOrderTraverse(BiTree T, Status (*Visit)(TElemType e)) &#123; InitStack(S); Push(S,T); //根指针进栈 while (!StackEmpty (S)) &#123; while(GetTop(S, p) &amp;&amp; p) Push (S,p-&gt;lchild); Pop(S, p); //空指针退栈 if (!StackEmpty(S))&#123; //访问节点，退后一步 Pop (S, p); if (!Visit(p-&gt;data)) return ERROR; Push(S,p-&gt;rchild); &#125; //if &#125; //while return OK; &#125; 层次遍历算法的非递归描述层次遍历，就是按照 顺序存储二叉树 的顺序来遍历。具体实现类似bfs，对于队列内的结点，把它们的（存在的）左儿子、右儿子依次入队。 123456789101112131415161718void translevel(BinNode *bt) &#123; struct BinNode *b; q.front=0; q.rear=0; if (!bt) return; q.elem[q.rear]=bt; q.rear=q.rear+1; while (q.front &lt; q.rear) &#123; b=q.elem[q.front]; q.front=q.front+1; printf(\"%c \",b-&gt;data); if (b-&gt;lch!=0) &#123; q.elem[q.rear]=b-&gt;lch; q.rear=q.rear+1; &#125; if (b-&gt;rch!=0) &#123; q.elem[q.rear]=b-&gt;rch; q.rear=q.rear+1; &#125; &#125;&#125; 例题若二叉树先序遍历的扩展序列为ABDECF*,其中代表空链域，则二叉树的后序遍历序列为*CFEDBA**。【j解析】后序遍历的最后一个必然是根。然后可以找到它在中序遍历的位置，左边为它的左子树，右边为右子树。 线索二叉树普通二叉树有lchild和rchild。线索二叉树，某个结点如果没有左子树，则lchild指向前驱；如果没有右子树，则rchild指向后继。线索二叉树还有ltag和rtag。如果有该子树，则该tag=0；否则为1.画实线表示指向子树；画虚线表示指向前驱后继。在根节点上方还有个结点，表示超级前驱/dog 森林的前中后序遍历先序：依次从左至右对森林中的每一棵树进行先根遍历中序：依次从左至右对森林中的每一棵树进行后根遍历 例题 赫夫曼树（1）赫夫曼树中没有度为1的结点（2）赫夫曼树中结点总数n为2n0 -1画法同离散。 第7章 图图的基本术语 网：弧或变带权的图分别称作有向网和无向网。 完全图：有n*(n-1)/2条边的无向图。 有向完全图：有n*(n-1)条边的有向图。 e &lt; nlogn 稀疏图；否则称为稠密图。 有向图中定点的度=出度+入度 强连通图：任意两个顶点之间都存在一条有向路径的有向图。否则，其各个强连通子图称作它的强连通分量。 第8章 动态存储管理第9章 查找第10章 内部排序","categories":[],"tags":[{"name":"大学专业课","slug":"大学专业课","permalink":"http://glisses.github.io/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"matlab函数-mapminmax","slug":"matlab函数-mapminmax","date":"2021-05-02T17:13:46.000Z","updated":"2021-06-23T09:28:04.195Z","comments":true,"path":"2021/05/03/matlab函数-mapminmax/","link":"","permalink":"http://glisses.github.io/2021/05/03/matlab%E5%87%BD%E6%95%B0-mapminmax/","excerpt":"mapminmax——matlab自带的数据标准化方法本文涉及mapminmax函数的四种用法，如下： 1234[Y,PS] = mapminmax(X,Ymin,Ymax)[Y,PS] = mapminmax(X,FP)Y = mapminmax(‘apply’,X,PS)X = mapminmax(‘reverse’,Y,PS)","text":"mapminmax——matlab自带的数据标准化方法本文涉及mapminmax函数的四种用法，如下： 1234[Y,PS] = mapminmax(X,Ymin,Ymax)[Y,PS] = mapminmax(X,FP)Y = mapminmax(‘apply’,X,PS)X = mapminmax(‘reverse’,Y,PS) [Y,PS] = mapminmax(X,Ymin,Ymax)运行如下代码（默认Ymin=-1， Ymax=1）： 123x1 = [1,2,4][y,ps]=mapminmax(x1)y 这里的ps， 是记录【从x到y的映射规则】的结构体。上图的运行结果中，可以看到：x为一行，x的最大值是4，最小值是1，x的最大值与最小值之差（xrange）是3；y为一行，最大1，最小-1，y的最大值与最小值之差是2， 从x到y的映射规则是： 12if (xmax != xmin) y = (ymax-ymin)*(x-xmin)/(xmax-xmin) + ymin; else y = ymin; 这样就避免了标准化时除0出错。 [Y,PS] = mapminmax(X,FP)这种形式，是让Y=X的FP映射，PS=FP。运行以下代码： 1234x1 = [1,2,4][y,ps]=mapminmax(x1)ps.ymin = 0[y,pq]=mapminmax(x1,ps) 运行结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667x1 = 1 2 4y = -1.0000 -0.3333 1.0000ps = 包含以下字段的 struct: name: 'mapminmax' xrows: 1 xmax: 4 xmin: 1 xrange: 3 yrows: 1 ymax: 1 ymin: -1 yrange: 2 gain: 0.6667 xoffset: 1 no_change: 0ps = 包含以下字段的 struct: name: 'mapminmax' xrows: 1 xmax: 4 xmin: 1 xrange: 3 yrows: 1 ymax: 1 ymin: 0 yrange: 2 gain: 0.6667 xoffset: 1 no_change: 0y = 0 0.3333 1.0000pq = 包含以下字段的 struct: name: 'mapminmax' xrows: 1 xmax: 4 xmin: 1 xrange: 3 yrows: 1 ymax: 1 ymin: 0 yrange: 1 gain: 0.3333 xoffset: 1 no_change: 0 可以看到，在改变ps.ymin后，ps这个结构体改变了。pq则被赋予了ps的值。 Y = mapminmax(‘apply’,X,PS)看到这个apply，应该可以猜到，这是应用PS映射规则，让Y为X在PS映射规则下的输出。 X = mapminmax(‘reverse’,Y,PS)看到这个reverse，可以猜到这是对Y作反映射，得到原来的X。运行以下代码： 123x = [5,8,42][y,ps] = mapminmax(x)x = mapminmax('reverse',y,ps) 可以得到输出： 123x = 5 8 42 Reference 如何在GitHub提交图片，做一个自己的图片仓库 https://www.imooc.com/article/284213 matlab中mapminmax函数的总结 https://xingqingsafe.github.io/2019/04/12/matlab-zhong-mapminmax-han-shu-de-zong-jie/","categories":[],"tags":[{"name":"matlab","slug":"matlab","permalink":"http://glisses.github.io/tags/matlab/"}]},{"title":"网站搭建相关问题及参考博客","slug":"网站搭建时遇到的问题及参考的博客","date":"2021-03-10T19:46:35.000Z","updated":"2021-09-09T05:42:10.233Z","comments":true,"path":"2021/03/11/网站搭建时遇到的问题及参考的博客/","link":"","permalink":"http://glisses.github.io/2021/03/11/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%8F%82%E8%80%83%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"sudo: cd: command not found【参考博客】https://www.cnblogs.com/phpper/p/7638039.html 宝塔面板忘记账号密码【参考博客】https://www.bt.cn/bbs/thread-1172-1-1.html 用ip访问宝塔面板，遇到安全入口校验问题，错误信息为","text":"sudo: cd: command not found【参考博客】https://www.cnblogs.com/phpper/p/7638039.html 宝塔面板忘记账号密码【参考博客】https://www.bt.cn/bbs/thread-1172-1-1.html 用ip访问宝塔面板，遇到安全入口校验问题，错误信息为 12345678910请使用正确的入口登录面板错误原因：当前宝塔新安装的已经开启了安全入口登录，新装机器都会随机一个8位字符的安全入口名称，亦可以在面板设置处修改，如您没记录或不记得了，可以使用以下方式解决解决方法：在SSH终端输入以下一种命令来解决1.查看面板入口：/etc/init.d/bt default2.关闭安全入口：rm -f /www/server/panel/data/admin_path.pl ==注意：【关闭安全入口】将使您的面板登录地址被直接暴露在互联网上，非常危险，请谨慎操作 #F44336== 【参考博客】https://www.php.cn/topic/bt/431131.html ssh连接，无法访问宝塔面板，错误信息类似为123456789 外网面板地址: http://121.196.***.176:8888/c4c*****内网面板地址: http://172.17.**.6:8888/c4c******以下仅为初始默认账户密码，若无法登录请执行bt命令重置账户/密码登录username: qbtr****password: ebc*****If you cannot access the panel,release the following panel port [8888] in the security group若无法访问面板，请检查防火墙/安全组是否有放行面板[8888]端口 【参考博客】 https://blog.csdn.net/wjkwan/article/details/111709579 https://www.bt.cn/bbs/thread-2897-1-1.html","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://glisses.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"往年国赛论文+命题杂谈","slug":"往年国赛论文+命题杂谈","date":"2020-09-04T07:58:16.000Z","updated":"2021-09-09T05:42:01.667Z","comments":true,"path":"2020/09/04/往年国赛论文+命题杂谈/","link":"","permalink":"http://glisses.github.io/2020/09/04/%E5%BE%80%E5%B9%B4%E5%9B%BD%E8%B5%9B%E8%AE%BA%E6%96%87+%E5%91%BD%E9%A2%98%E6%9D%82%E8%B0%88/","excerpt":"2019命题A物理略 B物理19年的难题担当，主要是物理细节难导致建模困难。鼓的运动包括平动和转动，要采用牛顿-欧拉公式。这一点卡掉了很多人。鼓在倾斜时，绳子们的角度也会不同，如果不考虑，也会造成很大误差。但是感觉太物理了，不怎么数学？？？就是把物理公式列好。（虽然列好很难 C排队论非常开放的一道题，甚至机场数据都是要自己找。比较考思维的严谨性，而代码水平要求低。附一个知乎er@Lumir用Flexsim做的仿真模型https://www.bilibili.com/video/av68012983 2019-A190和下面那篇对比起来，论文没有那么出彩但代码部分规范、可读性好，还有高亮。http://dxs.moe.gov.cn/zx/a/qkt_sxjm_lw_2019qgdxssxjmjslwzs/191029/1529313.shtml 2019-B047在19年b组中，罕见地把空气阻力也考虑了。论文中的图看起来就很教科书，用词也很精准，对于几乎每个变量都会先说明它们受哪些变量影响。但是它的代码比较难读懂，感觉和论文的水平不一致。。。http://www.univs.cn/zx/a/qkt_sxjm_lw/191029/1507842.shtml 2019-C137论文写的挺好，结构分的很清，语言也比较简洁。","text":"2019命题A物理略 B物理19年的难题担当，主要是物理细节难导致建模困难。鼓的运动包括平动和转动，要采用牛顿-欧拉公式。这一点卡掉了很多人。鼓在倾斜时，绳子们的角度也会不同，如果不考虑，也会造成很大误差。但是感觉太物理了，不怎么数学？？？就是把物理公式列好。（虽然列好很难 C排队论非常开放的一道题，甚至机场数据都是要自己找。比较考思维的严谨性，而代码水平要求低。附一个知乎er@Lumir用Flexsim做的仿真模型https://www.bilibili.com/video/av68012983 2019-A190和下面那篇对比起来，论文没有那么出彩但代码部分规范、可读性好，还有高亮。http://dxs.moe.gov.cn/zx/a/qkt_sxjm_lw_2019qgdxssxjmjslwzs/191029/1529313.shtml 2019-B047在19年b组中，罕见地把空气阻力也考虑了。论文中的图看起来就很教科书，用词也很精准，对于几乎每个变量都会先说明它们受哪些变量影响。但是它的代码比较难读懂，感觉和论文的水平不一致。。。http://www.univs.cn/zx/a/qkt_sxjm_lw/191029/1507842.shtml 2019-C137论文写的挺好，结构分的很清，语言也比较简洁。 在开放题的背景下，这篇论文凭借不错的分类讨论、细节考量而出彩。它按节假日/工作日、忙期/闲期的四种情况，分别讨论了司机的决策。也考虑到了携带大件行李乘客占比、行车速度等对决策的影响。又对乘客更多、车更多、乘客和车平衡的三种情况建模分析，进行了优化。图20是个流程图，他们在放图时把文字分栏，这样排版更好看惹~ 本题中，一些数值的随机化是个难点。他们也没有选择硬刚，就用了简单的分布来拟合，然后在模型缺点中指出这是他们的不足。 http://dxs.moe.gov.cn/zx/a/qkt_sxjm_lw_2019qgdxssxjmjslwzs/191029/1528083.shtml 2018命题A/dog一堆传热学知识，难顶啊。模型建好了OK，没建好完蛋。 难点1：在于合理的数值结构。以有限差分为例，向前差分格式网格比小于等于0.5这件事能搞死大部分学生的笔记本。合理的解决方案：多重网格，在pde的K值比较大的介质上用小网格，K值比较小的介质上用大网格平趟。 难点2：问题2和3没有明确给出如命题一中类似的边界条件，这两个题的正演都做不了，你还跟我谈什么反演？合理的解决方案：假定人体内部（即从皮肤向内部延拓一定的深度8-10mm应该就差不多了）的温度是37度，重新给定介质为五层的结构，即第五层是皮肤以内8-10mm的介质。查了人的密度为1.06，比热为4200，导热系数为0.432，算出来结果巨大无比————》网格细化没商量。有了正演过程的建立，反演就很容易了。 作者：落飞链接：https://www.zhihu.com/question/294523902/answer/491882948 B在读题上设置了不少障碍，虽然简单但是繁琐，很多队伍因为题目没理顺被劝退。创新奖用了启发式算法。这题看着朴素，实际上评奖的论文也大多是采用了朴素的贪心啊动态规划之类。而套用智能算法（如遗传）的基本无了。以及有说，选了这道仿（带）真（模）题（拟）之后，找bug调bug的时间大大增加。如果我们要选这种题，一定要预留足够的时间嘤嘤嘤。 第一题模型明确，主要考察会不会算；第二题基本模型明确，计算模型需要设计一下，算法明确，实现有点儿难度，毕竟不好手算。 2018-A466简洁明了，论文罕见的短。有种“大佬会了就是会了，这题给你秒了”的感觉。。。http://dxs.moe.gov.cn/zx/a/qkt_sxjm_lw_2018qgdxssxjmjslwzs/181101/1529331.shtml 2018-B203使用了正确的算法，算出了比较正确的答案，但是感觉有点平平无奇。论文写的像程序设计基础训练的pdf，流程图也比较朴素。http://dxs.moe.gov.cn/zx/a/qkt_sxjm_lw_2018qgdxssxjmjslwzs/181101/1529329.shtml 2018-B-华东师范国一论文这篇论文不错，写的很简洁明了，图画的也不错。这题本身也是捋顺了就好做了。用的python。https://github.com/njzjz/2018CUMCM-B/blob/master/paper.docx 留坑待填 2017命题AB2017-A2017-B 总结出题组应该也不希望本科生好高骛远，套那些智能算法。近年的展示论文都是用比较朴素、本科生可以掌握的算法来做的。官网展示里少数论文，参考文献只有两三篇。在知乎找到的2018B题国一论文，参考文献15篇。多参考一些也许会更好。&amp;疑惑为什么论文基本没有代码高亮和文字加粗。。。明明会方便阅读很多。。。","categories":[],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://glisses.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}]},{"title":"matlab杂谈","slug":"matlab杂谈","date":"2020-09-03T02:59:35.000Z","updated":"2021-09-09T05:41:54.189Z","comments":true,"path":"2020/09/03/matlab杂谈/","link":"","permalink":"http://glisses.github.io/2020/09/03/matlab%E6%9D%82%E8%B0%88/","excerpt":"matlab 自带inf .*和./ matlab中./与/有什么区别 点运算是处理元素之间的运算 直接/在矩阵计算中只能处理符合矩阵运算法则的运算 矩阵计算和作图都是点运算 在对数值计算时，“./”和“/”其实是没有区别的。 例：对于矩阵A=[a b c d]，1./A=[1/a 1/b 1/c 1/d]，而1/A表示的是A的逆 @可以作为函数句柄，即自定义函数类似物。也可以用作给函数传参。 https://blog.csdn.net/weixin_38009585/article/details/81016997","text":"matlab 自带inf .*和./ matlab中./与/有什么区别 点运算是处理元素之间的运算 直接/在矩阵计算中只能处理符合矩阵运算法则的运算 矩阵计算和作图都是点运算 在对数值计算时，“./”和“/”其实是没有区别的。 例：对于矩阵A=[a b c d]，1./A=[1/a 1/b 1/c 1/d]，而1/A表示的是A的逆 @可以作为函数句柄，即自定义函数类似物。也可以用作给函数传参。 https://blog.csdn.net/weixin_38009585/article/details/81016997 ’表示矩阵转置 ：的使用： https://blog.csdn.net/rosefun96/article/details/78441751 在matlab中，波浪号 ~（也就是键盘上数字键1 旁边的那个）主要有两个用法： 第一是代表与或非中的非，如在以下代码中： 123if ~flag ……end 只有在flag为0或false时，才会执行省略号对应的部分另外，matlab中不等号的写法是：~= 第二是代表忽略输出参数，如unique函数有三个输出参数，而我们只需要第二个参数，那可以这样： 1[~,rank,~]=unique(array,'rows'); 代表我们忽略了第一和第三个参数，而如果我们不加波浪号的话 1rank=unique(array,'rows'); 这表示接收第一个参数，就不是我们想要的啦 https://blog.csdn.net/songyunli1111/article/details/78501250 repmat全称是Replicate Matrix ，意思是复制和平铺矩阵，是MATLAB里面的一个函数。语法有B = repmat(A,m,n)，将矩阵 A 复制 m×n 块，即把 A 作为 B 的元素，B 由 m×n 个 A 平铺而成。B 的维数是 [size(A,1)m, size(A,2)n] 。 diag，构造对角矩阵 1234567&gt;&gt; A = diag([100 200 300])A = 100 0 0 0 200 0 0 0 300 TSP问题：旅行商问题。路人甲要去n个地儿，每个地儿只能去一次，最后还得回家，求最小路径和。 遗传算法：用于求解较为复杂的组合优化问题。 蚁群算法具有分布计算、信息正反馈和启发式搜索的特征，本质上是进化算法中的一种启发式全局优化算法。蚁群算法弊端：可能陷入局部最优解。蚁群算法改良版有：最大最小蚁群、排序蚁群、基于遗传算法的蚁群 排队论：顾客希望服务机构更大，这样就不用排队。但是服务机构大就烧钱。排队论是在顾客需要和服务机构的规模之间找平衡。 一些建模软件：comsol 多物理场建模FlexSim 离散仿真优化、是一个基于Windows的，面向对象的仿真环境，用于建立离散事件流程过程，像是制造业，物料处理和办公室工作流，这些全都配以相似度极高的三维虚拟现实环境。","categories":[],"tags":[{"name":"code","slug":"code","permalink":"http://glisses.github.io/tags/code/"}]},{"title":"近期学的一些AI相关知识总结-20200809","slug":"近期学的一些AI相关知识总结-20200809","date":"2020-08-09T04:31:34.000Z","updated":"2021-09-09T05:41:47.692Z","comments":true,"path":"2020/08/09/近期学的一些AI相关知识总结-20200809/","link":"","permalink":"http://glisses.github.io/2020/08/09/%E8%BF%91%E6%9C%9F%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9BAI%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-20200809/","excerpt":"softmaxsoftmax是一种函数，假设数组中有n个元素，j表示第i个元素，那么这个元素的softmax值为 Si = e^i/Σj e^j 参考文献：1.https://blog.csdn.net/bitcarmanlee/article/details/82320853 cross-entropy / 交叉熵在二分类问题中，你可以根据神经网络节点的输出，通过一个激活函数如Sigmoid，将其转换为属于某一类的概率，为了给出具体的分类结果，你可以取0.5作为阈值，凡是大于0.5的样本被认为是正类，小于0.5则认为是负类。","text":"softmaxsoftmax是一种函数，假设数组中有n个元素，j表示第i个元素，那么这个元素的softmax值为 Si = e^i/Σj e^j 参考文献：1.https://blog.csdn.net/bitcarmanlee/article/details/82320853 cross-entropy / 交叉熵在二分类问题中，你可以根据神经网络节点的输出，通过一个激活函数如Sigmoid，将其转换为属于某一类的概率，为了给出具体的分类结果，你可以取0.5作为阈值，凡是大于0.5的样本被认为是正类，小于0.5则认为是负类。 然而这样的做法并不容易推广到多分类问题。多分类问题神经网络最常用的方法是根据类别个数n，设置n个输出节点，这样每个样本神经网络都会给出一个n维数组作为输出结果，然后我们运用激活函数如softmax，将输出转换为一种概率分布，其中的每一个概率代表了该样本属于某类的概率。 比如一个手写数字识别这种简单的10分类问题，对于数字1的识别，神经网络模型的输出结果应该越接近[0,1,0,0,0,0,0,0,0,0]越好，其中[0,1,0,0,0,0,0,0,0,0]是最理想的结果了 但是如何衡量一个神经网络输出向量和理想的向量的接近程度呢？交叉熵（cross entropy）就是这个评价方法之一，他刻画了两个概率分布之间的距离，是多分类问题中常用的一种损失函数。 给定两个概率分布：p（理想结果即正确标签向量）和q（神经网络输出结果即经过softmax转换后的结果向量），则通过q来表示p的交叉熵为： H(p,q) = **−**∑x p(x) · logq(x) 注意：既然p和q都是一种概率分布，那么对于任意的x，应该属于[0,1]并且所有概率和为1 ∀x, p(X=x)ϵ[0,1] 且 ∑x p(X=x) = 1 交叉熵刻画的是通过概率分布q来表达概率分布p的困难程度，其中p是正确答案，q是预测值，也就是交叉熵值越小，两个概率分布越接近。 【样例】： p是[1,0,0]，某模型经过Softmax激活后的答案即预测值q是[0.5,0.4,0.1]，那么这个预测值和正确答案之间的交叉熵为： H(p=[1,0,0],q=[0.5,0.4,0.1])=−(1∗log0.5+0∗log0.4+0∗log0.1)≈0.3 如果另外一个模型的预测值q是[0.8,0.1,0.1]，那么这个预测值和正确答案之间的交叉熵为： H(p=[1,0,0],q=[0.8,0.1,0.1])=−(1∗log0.8+0∗log0.1+0∗log0.1)≈0.1 从直观上可以很容易的知道第二个预测答案要优于第一个，通过交叉熵计算得到的结果也是一致的。 12345678910111213import tensorflow as tf labels = [[0.2,0.3,0.5], [0.1,0.6,0.3]]logits = [[4,1,-2], [0.1,1,3]] logits_scaled = tf.nn.softmax(logits)result = tf.nn.softmax_cross_entropy_with_logits(labels=labels, logits=logits) with tf.Session() as sess: print (sess.run(logits_scaled)) print (sess.run(result)) 运行结果： 123[[0.95033026 0.04731416 0.00235563] [0.04622407 0.11369288 0.84008306]][3.9509459 1.6642545] 参考文献： 1.https://blog.csdn.net/yhily2008/article/details/80262321 2.https://www.cnblogs.com/always-fight/p/10370412.html 梯度下降法、随机梯度下降法、小批量梯度下降法梯度下降使用整个训练数据集来计算梯度，因此它有时也被称为批量梯度下降下面就以均方误差讲解一下，假设损失函数如下：其中 是预测值， 是真实值，那么要最小化上面损失 ,需要对每个参数 运用梯度下降法：其中 是损失函数对参数 的偏导数、 是学习率，也是每一步更新的步长。 随机梯度下降法在机器学习\\深度学习中，目标函数的损失函数通常取各个样本损失函数的平均，那么假设目标函数为：其中 是第 个样本的目标函数，那么目标函数在在 处的梯度为：如果使用梯度下降法(批量梯度下降法)，那么每次迭代过程中都要对 个样本进行求梯度，所以开销非常大，随机梯度下降的思想就是随机采样一个样本 来更新参数，那么计算开销就从 下降到 。小批量梯度下降法随机梯度下降虽然提高了计算效率，降低了计算开销，但是由于每次迭代只随机选择一个样本，因此随机性比较大，所以下降过程中非常曲折(图片来自《动手学深度学习》)，所以，样本的随机性会带来很多噪声，我们可以选取一定数目的样本组成一个小批量样本，然后用这个小批量更新梯度，这样不仅可以减少计算成本，还可以提高算法稳定性。小批量梯度下降的开销为 其中 是批量大小。 参考文献：https://www.zhihu.com/question/264189719/answer/932262940 ResNetDenseNetdense net 参考文献：1.https://zhuanlan.zhihu.com/p/37189203 两种 attentionFBblocks","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://glisses.github.io/tags/AI/"}]},{"title":"计算思维训练-期末考","slug":"计算思维训练-期末考","date":"2020-07-10T09:22:16.000Z","updated":"2021-09-09T05:41:27.538Z","comments":true,"path":"2020/07/10/计算思维训练-期末考/","link":"","permalink":"http://glisses.github.io/2020/07/10/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-%E6%9C%9F%E6%9C%AB%E8%80%83/","excerpt":"前言：暑假吼吼吼放完假就可以开学了吼吼吼Problem D. 分米粒时间限制 ？？ ms内存限制 ？？ MB 题目描述//因为过时间看不到了所以不可描述大概意思是有n堆按顺序的米，你可以拿隔板把它们隔开，两隔板之间的若干堆米为一份。已知你有m块隔板。求经过你睿智的隔板设置后，每份米的最大值，最小是多少。","text":"前言：暑假吼吼吼放完假就可以开学了吼吼吼Problem D. 分米粒时间限制 ？？ ms内存限制 ？？ MB 题目描述//因为过时间看不到了所以不可描述大概意思是有n堆按顺序的米，你可以拿隔板把它们隔开，两隔板之间的若干堆米为一份。已知你有m块隔板。求经过你睿智的隔板设置后，每份米的最大值，最小是多少。 输入数据//不可描述 输出数据//不可描述 样例输入//不记得样例了，再来一个 5 27 2 1 9 3125 33 9 1 2 710 样例输出1210 样例说明无 算法 二分查找模板题。不过有些同学考试的时候比较紧张，可能没有看出来。因为这道题没有排序嘛，会觉得噫这题不用排序那是不是就不能用二分查找了？其实不然。我们看看这道题满足什么条件？米堆的顺序不可调整！也就是有一个数组a[i]，它的顺序是不变的。如果二分查找的题目做多了，就很发现它其实是很常见的一种应用二分查找的题型。 二分查找是在，前面的如果能满足，后面的一定能满足，的条件下才能使用。再来看这道题，如果 每份米的最大值 最小不超过10，那 每份米的最大值 最小是不是肯定不超过比10大的数？是的，那么它就可以使用二分查找。 接下来说说怎么用，也就是二分查找的Check()函数怎么写。我们在放隔板的时候，因为米堆的顺序固定，所以一旦某一堆的和+a[i]超过了k，我们就得在a[i]之前放一个隔板。也就是说，我们可以在循环1-n时，每次累加当前米堆的和，当它要超过k时，隔板数+1。如果某时刻隔板数&gt;m，你就知道，米堆最大值最小是k这个条件，是无法满足的，return false。 下面是具体的代码实现。 1234567891011121314151617181920212223242526272829303132333435bool Check(int x)&#123; int sum=0,cnt=0; ufor (i,1,n) &#123; if (sum+a[i]&gt;x) sum=a[i],cnt++; else sum+=a[i]; &#125; return cnt+1&lt;=m;&#125;int main()&#123; while (scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) &#123; int summ=0,maxx=0; ufor (i,1,n) &#123; scanf(\"%d\",&amp;a[i]); summ+=a[i]; maxx=max(maxx,a[i]); &#125; int l=maxx,r=summ; while (l&lt;r) &#123; int mid=(l+r)/2; if (Check(mid)) r=mid; else l=mid+1; &#125; //printf(\"%d\\n\",r); //while (!Check(r)) r--; cout&lt;&lt;l&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"大学专业课","slug":"大学专业课","permalink":"http://glisses.github.io/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"计算思维训练-20200707","slug":"计算思维训练-20200707","date":"2020-07-07T08:21:27.000Z","updated":"2021-09-09T05:41:35.512Z","comments":true,"path":"2020/07/07/计算思维训练-20200707/","link":"","permalink":"http://glisses.github.io/2020/07/07/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200707/","excerpt":"Problem F. 安全的密码mark text时间限制 1000 ms内存限制 256 MB 题目描述众所周知，密码安全是互联网时代人们最为关心的事情之一。而 RSA 公钥加密算法是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击。","text":"Problem F. 安全的密码mark text时间限制 1000 ms内存限制 256 MB 题目描述众所周知，密码安全是互联网时代人们最为关心的事情之一。而 RSA 公钥加密算法是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击。 其实 RSA 公钥加密算法的原理并不复杂，它基于一个十分简单的数论事实：将两个大素数相乘十分容易，而想要对其乘积进行质因数分解却极其困难，因此可以将乘积公开作为加密密钥。 所以 RSA 算法很重要的一个过程就是得到两个大素数相乘结果。 wchhlbt 和 Lazy_sheep 想要模拟一下 RSA 算法的加密过程。现在 wchhlbt拿到了 Lazy_sheep 提供的一份素数相乘的结果，但是 Lazy_sheep 因为别的事情计算的并不认真。 所以 wchhlbt 希望你来帮他判断这些数据的正确性。 输入数据第一行为一个整数 t (1≤t≤1000)，表示数据的组数。接下来对于每组数据：第一行为一个整数 n (2≤n≤2×109)。 输出数据对于每组数据，输出一行：如果这个数可以分解为两个素数乘积，输出YES，否则输出NO。 样例输入46835121样例输出YESNOYESYES样例说明无 算法 一个数学题，绕过了一道弯，写得好的代码应该在二十行左右。对于每一个N，我们首先要想，如果它是两个素数的乘积，它一定满足什么条件？两个素数的乘积，一定不会是其他素数的倍数。如果一个数是两个大于一百的素数的乘积，它还有可能是2的倍数吗？不可能。这说明什么？如果n是两个素数的乘积，一旦我们找到了n的一个约数x，它的另一个约数就找到了（也就是n/x），而n不会再有其他约数，也就是循环不用继续下去。 那么这道题的做法也就显而易见。我们从2到(int)sqrt(n)循环，一旦找到一个n的约数x，就看n/x是不是素数。是素数，就是YES，不然就是NO。BTW，这里x是不是素数是不用判断的。原因是____. 1234567891011121314151617int main()&#123; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); bool flag=false; ufor (i,2,(int) sqrt(n)) if (n%i==0) &#123; if (Sushu(n/i)) flag=true; break; &#125; printf((flag)? \"YES\\n\":\"NO\\n\"); &#125; return 0;&#125; 思考题：在以上的for循环中，为什么要写两个if，而不是在两个判断之间用&amp;&amp;? Problem G. 课堂作业-4-4时间限制 1000 ms内存限制 64 MB 题目描述小明刚买了一个机械键盘，但他在用机械键盘打字的时候发现键盘的Home键和End键坏掉了，于是他在打字的时候光标有时会突然跑到行首，有时又会突然跑到行尾，现在给你键盘的输入，求最后屏幕上的字符串。 输入数据输入数据为一行字符串，字符串只包含小写英文字母,’[‘符号以及’]’符号，’[‘代表按下了Home键，‘]’代表按下了End键，字符串长度不超过100000。 输出数据输出最后屏幕上的字符串。 样例输入 xiechengxuz[henhao]wan 样例输出 henhaoxiechengxuzwan 样例说明可能出现多个’[‘和’]’，也可能没有’[‘和’]’ 解法 在说解法之前，先来捋一捋这题是什么意思。对于一个更典型的样例 1[dsafd]af[daf]ewa[]f[ds 它的输出应当是 1dsdafdsafdafewaf 这是怎么出来的呢？在队首，先有dsafd，然后daf插到它前面去了，接着ds又在它俩前面，所以输出的前面部分是dsdafdsafd。然后是中间部分。这里有一个结论，是中间部分必然在所有的[和]之前。输出中间部分（本样例无）之后，是队尾部分。队尾先有af，然后ewa排在它后面，f也在后面。所以最终输出为dsdafdsafdafewaf。 这题通过和大佬们讨论，本菜鸡获得了三个方法。以下引用均已获得许可。 一、strcat by JJHDL其实这道题麻烦的地方就在队首而已。然后strcat是一个在时间复杂度上正常，而在代码编写难易程度上出色的一个函数。对于上面那个样例，我们就是把daf用strcat插到前面，再把ds插到前面。这个比较好理解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int main(void)&#123; scanf(\"%s\",s); int len = strlen(s); ans[0] = '\\0'; tmp[0] = '\\0'; int top = -1; int last = -1; for (int i=0;i&lt;len;i++) &#123; if (s[i]=='[') &#123; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; top=-1; last = 1; continue; &#125; if (s[i]==']') &#123; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; top = -1; last = -1; continue; &#125; tmp[++top] = s[i]; &#125; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; printf(\"%s\\n\",ans); return 0;&#125; 该做法与链表类似。 二、倒序存 by GlisCJ我对于队首的处理方法是这样的：首先，在样例中，在队首的那几个字符串是 dsafd daf ds 是比较容易得到的。然后我们如何能更直接地存储它们呢？我想到一个方法，就是把每个分开的队首字符串都倒着存，这样会得到dfasd fad sd 。再把这个字符串倒序输出，就是 dsdafdsafd ，也就是我们想要的答案。这个也比较好理解，代码如下： 123456789101112131415161718192021222324252627282930int main()&#123; scanf(\"%s\",s); n=strlen(s); int i=0; while (i&lt;n) &#123; while (s[i]=='[') &#123; int x=0; while (s[i]=='[') i++; while (i&lt;n &amp;&amp; s[i]!=']' &amp;&amp; s[i]!='[') a[x++]=s[i++]; dfor (j,x-1,0) st[cur++]=a[j]; &#125; i++; &#125; dfor (i,cur-1,0) printf(\"%c\",st[i]); i=0; while (i&lt;n) &#123; while (s[i]=='[' || s[i]==']') &#123; while (s[i]=='[') while (i&lt;n &amp;&amp; s[i]!=']') i++; while (s[i]==']' &amp;&amp; i&lt;n) i++; &#125; if (i&gt;=n) break; putchar(s[i++]); &#125; return 0;&#125; 然鹅我实在是太菜惹，把它当成了传统字符串处理题。楼下简直是模板。 三、deque by ZXDL队首，其实是相当于把一个个字符串不断放在第一位。队尾，其实是相当于把一个个字符串不断放在最后一位。那这就和stl中的deque的push_front()、push_back()操作完全吻合。这道题就像是这种数据结构的模板题，所以代码会非常清晰简明。这个也比较好理解，代码如下： 1234567891011121314151617181920int main() &#123; char buf[102400]; std::deque&lt;std::string&gt; input; scanf(\"%[^][\\n]\", buf); input.push_back(std::string(buf)); char c; while (c = getchar(), c != EOF) &#123; buf[0] = 0; if (c == '[') &#123; scanf(\"%[^][\\n]\", buf); input.push_front(std::string(buf)); &#125; else if (c == ']') &#123; scanf(\"%[^][\\n]\", buf); input.push_back(std::string(buf)); &#125; &#125; for (auto &amp; i : input) &#123; std::cout &lt;&lt; i; &#125;&#125; 如果还是找不到错误原因的话，可以看看是不是在很多个[[[]]]]]][][][][][[[[]]]]相连的时候出错了。 友情链接：章鱼哥：https://fishercat.top/姜总：https://jjhqwq.top/","categories":[],"tags":[{"name":"大学专业课","slug":"大学专业课","permalink":"http://glisses.github.io/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"计算思维综合训练_2020_07_06","slug":"计算思维训练-20200706","date":"2020-07-06T09:04:29.000Z","updated":"2021-09-09T05:41:17.098Z","comments":true,"path":"2020/07/06/计算思维训练-20200706/","link":"","permalink":"http://glisses.github.io/2020/07/06/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200706/","excerpt":"Problem J. sqy 的锡纸烫时间限制 1000 ms内存限制 64 MB 题目描述渣男锡纸烫！ 前不久 sqy 老师花了大价钱，去做了一个帅气的锡纸烫。有着商业眼光的 sqy 一下子发现了大商机，于是他自己开了一家美容美发店。","text":"Problem J. sqy 的锡纸烫时间限制 1000 ms内存限制 64 MB 题目描述渣男锡纸烫！ 前不久 sqy 老师花了大价钱，去做了一个帅气的锡纸烫。有着商业眼光的 sqy 一下子发现了大商机，于是他自己开了一家美容美发店。 sqy 找了刚刚做完纹理烫的大预言家 cbj 预测了未来，发现每个顾客都只在白天来美发店，并且第一次来店里的时候都会充一次价值 xi 的卡，然后从第二天开始，每天白天都会来这里打理头发，而 sqy 仅收取成本价 1 元钱来吸引顾客，直到把卡掏空为止，这个顾客就再也不会回来。 黑心商人 sqy 找大预言家要来了每个顾客的充卡时间和充值金额，他准备在某一天晚上跑路，他想知道自己最多能卷走多少钱。 输入数据第一行包括一个整数 n(1≤n≤1e5) 表示有 n 个顾客。 接下来共 n 行，每i+1行包括两个整数 xi,yi 表示第 xi 天一个顾客来充值了 yi 元 (1≤xi≤1e6,0≤yi≤231−1)。 输出数据输出一行包括一个整数 ans，表示 sqy 最多能卷走多少钱。 样例输入51 52 53 54 55 5样例输出15样例说明在第五天的时候，第一个人消费4元还剩1元，第二个人消费3元还剩2元，第三个人消费2元还剩3元，第四个人消费1元还剩4元，第五个人还没有开始消费就被卷钱跑路了。 算法差分 首先介绍一下朴素的差分。我们有n个数，m个操作。设0&lt;=n,m&lt;=1e5。n个数和m个操作在读入中给出。m个操作的形式为三个正整数 l r x，表示将这n个数中的第l个到第r个都分别加上x。然后有n次询问，询问第p到第q个数之间所有数字的和为多少？ 比如当n=5,m=3原数列:5 7 6 2 4操作:1 3 24 4 73 5 1则最终数列为：7 9 9 10 5 对于这道题，如果我们朴素地对每个操作，都从l到r循环，给a[i]加上x的话，时间复杂度会是O(nm)&gt;1e8，造成超时(time limit exceeded)。于是差分就出现了。 差分，就是在区间的开头和结尾分别打上标记的一种操作。比如在这道题中，我们称原数组为a，标记数组为b。对于每个操作，我们让b[l]+=x,b[r+1]-=x;这么做有什么用呢？我们观察b的前缀和数组。 前缀和数组sum[i]的值就等于经过m次操作，从1到i位的数之和增大了多少。那么如何求l~r的数之和增大了多少呢？显然为sum[r+1]-sum[l]。 于是，对于每个询问，我们只需要输出原数组在l、r+1的前缀和之差 加上 b数组在l、r+1的前缀和之差。 那么，如何将差分运用到sqy的锡纸烫这道题呢？首先，要从题目给出的数据范围揣摩算法。我们看到一个有点反常的地方：(1≤xi≤1e6,0≤yi≤2^31−1)。为什么xi和yi的最大值差那么远呢？因为xi最大也不超过1e6，所以我们可以从这里入手。 首先，感性认识一下可以确定，sqy获得最多钱的那一天，一定是某位客人刚办卡而没开始消费的一天，也就是某个x[i]。那我们就可以从min x[i]到max x[i]循环。在这个循环中，有三个变量参与，它们分别是：cnt(i天有多少客人消费)、now(i天sqy手中的钱)、ans（我们要输出的值）。 123456for (i,？,？) &#123; cnt+=c[i]; now+=b[i]; now-=cnt; ans=max(ans,now); &#125; 既然cnt是i天有多少客人消费的前缀和，那么c显然就是某天有多少人消费的标记数组。b数组同理。具体的代码实现请继续思考。奥力给！ 友情链接：章鱼哥：https://fishercat.top/姜总：https://jjhqwq.top/","categories":[],"tags":[{"name":"大学专业课","slug":"大学专业课","permalink":"http://glisses.github.io/tags/%E5%A4%A7%E5%AD%A6%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]}]}