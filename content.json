{"meta":{"title":"glisses","subtitle":"","description":"","author":"glisses","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"计算思维训练-20200708","slug":"计算思维训练-20200708","date":"2020-07-08T01:49:33.000Z","updated":"2020-07-08T01:49:33.845Z","comments":true,"path":"2020/07/08/计算思维训练-20200708/","link":"","permalink":"http://yoursite.com/2020/07/08/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200708/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"计算思维训练-20200707","slug":"计算思维训练-20200707","date":"2020-07-07T08:21:27.000Z","updated":"2020-07-08T03:34:15.772Z","comments":true,"path":"2020/07/07/计算思维训练-20200707/","link":"","permalink":"http://yoursite.com/2020/07/07/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200707/","excerpt":"","text":"Problem F. 安全的密码mark text时间限制 1000 ms内存限制 256 MB 题目描述众所周知，密码安全是互联网时代人们最为关心的事情之一。而 RSA 公钥加密算法是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击。 其实 RSA 公钥加密算法的原理并不复杂，它基于一个十分简单的数论事实：将两个大素数相乘十分容易，而想要对其乘积进行质因数分解却极其困难，因此可以将乘积公开作为加密密钥。 所以 RSA 算法很重要的一个过程就是得到两个大素数相乘结果。 wchhlbt 和 Lazy_sheep 想要模拟一下 RSA 算法的加密过程。现在 wchhlbt拿到了 Lazy_sheep 提供的一份素数相乘的结果，但是 Lazy_sheep 因为别的事情计算的并不认真。 所以 wchhlbt 希望你来帮他判断这些数据的正确性。 输入数据第一行为一个整数 t (1≤t≤1000)，表示数据的组数。接下来对于每组数据：第一行为一个整数 n (2≤n≤2×109)。 输出数据对于每组数据，输出一行：如果这个数可以分解为两个素数乘积，输出YES，否则输出NO。 样例输入46835121样例输出YESNOYESYES样例说明无 算法 一个数学题，绕过了一道弯，写得好的代码应该在二十行左右。对于每一个N，我们首先要想，如果它是两个素数的乘积，它一定满足什么条件？两个素数的乘积，一定不会是其他素数的倍数。如果一个数是两个大于一百的素数的乘积，它还有可能是2的倍数吗？不可能。这说明什么？如果n是两个素数的乘积，一旦我们找到了n的一个约数x，它的另一个约数就找到了（也就是n/x），而n不会再有其他约数，也就是循环不用继续下去。 那么这道题的做法也就显而易见。我们从2到(int)sqrt(n)循环，一旦找到一个n的约数x，就看n/x是不是素数。是素数，就是YES，不然就是NO。BTW，这里x是不是素数是不用判断的。原因是____. 1234567891011121314int main()&#123; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); bool flag=false; ufor (i,2,(int) sqrt(n)) if (n%i==0) if (Sushu(n/i)) flag=true; else break; printf((flag)? \"YES\\n\":\"NO\\n\"); &#125; return 0;&#125; 思考题：在以上的for循环中，为什么要写两个if，而不是在两个判断之间用&amp;&amp;? Problem G. 课堂作业-4-4时间限制 1000 ms内存限制 64 MB 题目描述小明刚买了一个机械键盘，但他在用机械键盘打字的时候发现键盘的Home键和End键坏掉了，于是他在打字的时候光标有时会突然跑到行首，有时又会突然跑到行尾，现在给你键盘的输入，求最后屏幕上的字符串。 输入数据输入数据为一行字符串，字符串只包含小写英文字母,’[‘符号以及’]’符号，’[‘代表按下了Home键，‘]’代表按下了End键，字符串长度不超过100000。 输出数据输出最后屏幕上的字符串。 样例输入 xiechengxuz[henhao]wan 样例输出 henhaoxiechengxuzwan 样例说明可能出现多个’[‘和’]’，也可能没有’[‘和’]’ 解法 在说解法之前，先来捋一捋这题是什么意思。对于一个更典型的样例 1[dsafd]af[daf]ewa[]f[ds 它的输出应当是 1dsdafdsafdafewaf 这是怎么出来的呢？在队首，先有dsafd，然后daf插到它前面去了，接着ds又在它俩前面，所以输出的前面部分是dsdafdsafd。然后是中间部分。这里有一个结论，是中间部分必然在所有的[和]之前。输出中间部分（本样例无）之后，是队尾部分。队尾先有af，然后ewa排在它后面，f也在后面。所以最终输出为dsdafdsafdafewaf。 这题通过和大佬们讨论，本菜鸡获得了三个方法。以下引用均已获得许可。 一、strcat by JJHDL其实这道题麻烦的地方就在队首而已。然后strcat是一个在时间复杂度上正常，而在代码编写难易程度上出色的一个函数。对于上面那个样例，我们就是把daf用strcat插到前面，再把ds插到前面。这个比较好理解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int main(void)&#123; scanf(\"%s\",s); int len = strlen(s); ans[0] = '\\0'; tmp[0] = '\\0'; int top = -1; int last = -1; for (int i=0;i&lt;len;i++) &#123; if (s[i]=='[') &#123; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; top=-1; last = 1; continue; &#125; if (s[i]==']') &#123; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; top = -1; last = -1; continue; &#125; tmp[++top] = s[i]; &#125; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; printf(\"%s\\n\",ans); return 0;&#125; 该做法与链表类似。 二、倒序存 by GlisCJ我对于队首的处理方法是这样的：首先，在样例中，在队首的那几个字符串是 dsafd daf ds 是比较容易得到的。然后我们如何能更直接地存储它们呢？我想到一个方法，就是把每个分开的队首字符串都倒着存，这样会得到dfasd fad sd 。再把这个字符串倒序输出，就是 dsdafdsafd ，也就是我们想要的答案。这个也比较好理解，代码如下： 123456789101112131415161718192021222324252627282930int main()&#123; scanf(\"%s\",s); n=strlen(s); int i=0; while (i&lt;n) &#123; while (s[i]=='[') &#123; int x=0; while (s[i]=='[') i++; while (i&lt;n &amp;&amp; s[i]!=']' &amp;&amp; s[i]!='[') a[x++]=s[i++]; dfor (j,x-1,0) st[cur++]=a[j]; &#125; i++; &#125; dfor (i,cur-1,0) printf(\"%c\",st[i]); i=0; while (i&lt;n) &#123; while (s[i]=='[' || s[i]==']') &#123; while (s[i]=='[') while (i&lt;n &amp;&amp; s[i]!=']') i++; while (s[i]==']' &amp;&amp; i&lt;n) i++; &#125; if (i&gt;=n) break; putchar(s[i++]); &#125; return 0;&#125; 然鹅我实在是太菜惹，把它当成了传统字符串处理题。楼下简直是模板。 三、deque by ZXDL队首，其实是相当于把一个个字符串不断放在第一位。队尾，其实是相当于把一个个字符串不断放在最后一位。那这就和stl中的deque的push_front()、push_back()操作完全吻合。这道题就像是这种数据结构的模板题，所以代码会非常清晰简明。这个也比较好理解，代码如下： 1234567891011121314151617181920int main() &#123; char buf[102400]; std::deque&lt;std::string&gt; input; scanf(\"%[^][\\n]\", buf); input.push_back(std::string(buf)); char c; while (c = getchar(), c != EOF) &#123; buf[0] = 0; if (c == '[') &#123; scanf(\"%[^][\\n]\", buf); input.push_front(std::string(buf)); &#125; else if (c == ']') &#123; scanf(\"%[^][\\n]\", buf); input.push_back(std::string(buf)); &#125; &#125; for (auto &amp; i : input) &#123; std::cout &lt;&lt; i; &#125;&#125; 如果还是找不到错误原因的话，可以看看是不是在很多个[[[]]]]]][][][][][[[[]]]]相连的时候出错了。 友情链接：章鱼哥：https://fishercat.top/姜总：https://jjhqwq.top/","categories":[],"tags":[]},{"title":"计算思维综合训练_2020_07_06","slug":"计算思维训练-20200706","date":"2020-07-06T09:04:29.000Z","updated":"2020-07-06T11:58:35.486Z","comments":true,"path":"2020/07/06/计算思维训练-20200706/","link":"","permalink":"http://yoursite.com/2020/07/06/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200706/","excerpt":"","text":"Problem J. sqy 的锡纸烫时间限制 1000 ms内存限制 64 MB 题目描述渣男锡纸烫！ 前不久 sqy 老师花了大价钱，去做了一个帅气的锡纸烫。有着商业眼光的 sqy 一下子发现了大商机，于是他自己开了一家美容美发店。 sqy 找了刚刚做完纹理烫的大预言家 cbj 预测了未来，发现每个顾客都只在白天来美发店，并且第一次来店里的时候都会充一次价值 xi 的卡，然后从第二天开始，每天白天都会来这里打理头发，而 sqy 仅收取成本价 1 元钱来吸引顾客，直到把卡掏空为止，这个顾客就再也不会回来。 黑心商人 sqy 找大预言家要来了每个顾客的充卡时间和充值金额，他准备在某一天晚上跑路，他想知道自己最多能卷走多少钱。 输入数据第一行包括一个整数 n(1≤n≤1e5) 表示有 n 个顾客。 接下来共 n 行，每i+1行包括两个整数 xi,yi 表示第 xi 天一个顾客来充值了 yi 元 (1≤xi≤1e6,0≤yi≤231−1)。 输出数据输出一行包括一个整数 ans，表示 sqy 最多能卷走多少钱。 样例输入51 52 53 54 55 5样例输出15样例说明在第五天的时候，第一个人消费4元还剩1元，第二个人消费3元还剩2元，第三个人消费2元还剩3元，第四个人消费1元还剩4元，第五个人还没有开始消费就被卷钱跑路了。 算法差分 首先介绍一下朴素的差分。我们有n个数，m个操作。设0&lt;=n,m&lt;=1e5。n个数和m个操作在读入中给出。m个操作的形式为三个正整数 l r x，表示将这n个数中的第l个到第r个都分别加上x。然后有n次询问，询问第p到第q个数之间所有数字的和为多少？ 比如当n=5,m=3原数列:5 7 6 2 4操作:1 3 24 4 73 5 1则最终数列为：7 9 9 10 5 对于这道题，如果我们朴素地对每个操作，都从l到r循环，给a[i]加上x的话，时间复杂度会是O(nm)&gt;1e8，造成超时(time limit exceeded)。于是差分就出现了。 差分，就是在区间的开头和结尾分别打上标记的一种操作。比如在这道题中，我们称原数组为a，标记数组为b。对于每个操作，我们让b[l]+=x,b[r+1]-=x;这么做有什么用呢？我们观察b的前缀和数组。 前缀和数组sum[i]的值就等于经过m次操作，从1到i位的数之和增大了多少。那么如何求l~r的数之和增大了多少呢？显然为sum[r+1]-sum[l]。 于是，对于每个询问，我们只需要输出原数组在l、r+1的前缀和之差 加上 b数组在l、r+1的前缀和之差。 那么，如何将差分运用到sqy的锡纸烫这道题呢？首先，要从题目给出的数据范围揣摩算法。我们看到一个有点反常的地方：(1≤xi≤1e6,0≤yi≤2^31−1)。为什么xi和yi的最大值差那么远呢？因为xi最大也不超过1e6，所以我们可以从这里入手。 首先，感性认识一下可以确定，sqy获得最多钱的那一天，一定是某位客人刚办卡而没开始消费的一天，也就是某个x[i]。那我们就可以从min x[i]到max x[i]循环。在这个循环中，有三个变量参与，它们分别是：cnt(i天有多少客人消费)、now(i天sqy手中的钱)、ans（我们要输出的值）。 123456for (i,？,？) &#123; cnt+=c[i]; now+=b[i]; now-=cnt; ans=max(ans,now); &#125; 既然cnt是i天有多少客人消费的前缀和，那么c显然就是某天有多少人消费的标记数组。b数组同理。具体的代码实现请继续思考。奥力给！ 友情链接：章鱼哥：https://fishercat.top/姜总：https://jjhqwq.top/","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-03-12T02:51:24.479Z","updated":"2020-03-12T02:51:24.479Z","comments":true,"path":"2020/03/12/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}