{"meta":{"title":"glisses","subtitle":"","description":"","author":"glisses","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"近期学的一些AI相关知识总结-20200809","slug":"近期学的一些AI相关知识总结-20200809","date":"2020-08-09T04:31:34.000Z","updated":"2020-08-09T20:21:46.802Z","comments":true,"path":"2020/08/09/近期学的一些AI相关知识总结-20200809/","link":"","permalink":"http://yoursite.com/2020/08/09/%E8%BF%91%E6%9C%9F%E5%AD%A6%E7%9A%84%E4%B8%80%E4%BA%9BAI%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-20200809/","excerpt":"softmaxsoftmax是一种函数，假设数组中有n个元素，j表示第i个元素，那么这个元素的softmax值为 Si = e^i/Σj e^j 参考文献：1.https://blog.csdn.net/bitcarmanlee/article/details/82320853 cross-entropy","text":"softmaxsoftmax是一种函数，假设数组中有n个元素，j表示第i个元素，那么这个元素的softmax值为 Si = e^i/Σj e^j 参考文献：1.https://blog.csdn.net/bitcarmanlee/article/details/82320853 cross-entropy 在二分类问题中，你可以根据神经网络节点的输出，通过一个激活函数如Sigmoid，将其转换为属于某一类的概率，为了给出具体的分类结果，你可以取0.5作为阈值，凡是大于0.5的样本被认为是正类，小于0.5则认为是负类。 然而这样的做法并不容易推广到多分类问题。多分类问题神经网络最常用的方法是根据类别个数n，设置n个输出节点，这样每个样本神经网络都会给出一个n维数组作为输出结果，然后我们运用激活函数如softmax，将输出转换为一种概率分布，其中的每一个概率代表了该样本属于某类的概率。 比如一个手写数字识别这种简单的10分类问题，对于数字1的识别，神经网络模型的输出结果应该越接近[0,1,0,0,0,0,0,0,0,0]越好，其中[0,1,0,0,0,0,0,0,0,0]是最理想的结果了 但是如何衡量一个神经网络输出向量和理想的向量的接近程度呢？交叉熵（cross entropy）就是这个评价方法之一，他刻画了两个概率分布之间的距离，是多分类问题中常用的一种损失函数。 给定两个概率分布：p（理想结果即正确标签向量）和q（神经网络输出结果即经过softmax转换后的结果向量），则通过q来表示p的交叉熵为： H(p,q) = **−**∑x p(x) · logq(x) 注意：既然p和q都是一种概率分布，那么对于任意的x，应该属于[0,1]并且所有概率和为1 ∀x, p(X=x)ϵ[0,1] 且 ∑x p(X=x) = 1 交叉熵刻画的是通过概率分布q来表达概率分布p的困难程度，其中p是正确答案，q是预测值，也就是交叉熵值越小，两个概率分布越接近。 【样例】： p是[1,0,0]，某模型经过Softmax激活后的答案即预测值q是[0.5,0.4,0.1]，那么这个预测值和正确答案之间的交叉熵为： H(p=[1,0,0],q=[0.5,0.4,0.1])=−(1∗log0.5+0∗log0.4+0∗log0.1)≈0.3 如果另外一个模型的预测值q是[0.8,0.1,0.1]，那么这个预测值和正确答案之间的交叉熵为： H(p=[1,0,0],q=[0.8,0.1,0.1])=−(1∗log0.8+0∗log0.1+0∗log0.1)≈0.1 从直观上可以很容易的知道第二个预测答案要优于第一个，通过交叉熵计算得到的结果也是一致的。 12345678910111213import tensorflow as tf labels = [[0.2,0.3,0.5], [0.1,0.6,0.3]]logits = [[4,1,-2], [0.1,1,3]] logits_scaled = tf.nn.softmax(logits)result = tf.nn.softmax_cross_entropy_with_logits(labels=labels, logits=logits) with tf.Session() as sess: print (sess.run(logits_scaled)) print (sess.run(result)) 运行结果： 123[[0.95033026 0.04731416 0.00235563] [0.04622407 0.11369288 0.84008306]][3.9509459 1.6642545] 参考文献： 1.https://blog.csdn.net/yhily2008/article/details/80262321 non-localdense-net两种 attentionFBblocks","categories":[],"tags":[]},{"title":"计算思维训练-期末考","slug":"计算思维训练-期末考","date":"2020-07-10T09:22:16.000Z","updated":"2020-07-10T09:40:38.898Z","comments":true,"path":"2020/07/10/计算思维训练-期末考/","link":"","permalink":"http://yoursite.com/2020/07/10/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-%E6%9C%9F%E6%9C%AB%E8%80%83/","excerpt":"","text":"前言：暑假吼吼吼放完假就可以开学了吼吼吼Problem D. 分米粒时间限制 ？？ ms内存限制 ？？ MB 题目描述//因为过时间看不到了所以不可描述大概意思是有n堆按顺序的米，你可以拿隔板把它们隔开，两隔板之间的若干堆米为一份。已知你有m块隔板。求经过你睿智的隔板设置后，每份米的最大值，最小是多少。 输入数据//不可描述 输出数据//不可描述 样例输入//不记得样例了，再来一个 5 27 2 1 9 3125 33 9 1 2 710 样例输出1210 样例说明无 算法 二分查找模板题。不过有些同学考试的时候比较紧张，可能没有看出来。因为这道题没有排序嘛，会觉得噫这题不用排序那是不是就不能用二分查找了？其实不然。我们看看这道题满足什么条件？米堆的顺序不可调整！也就是有一个数组a[i]，它的顺序是不变的。如果二分查找的题目做多了，就很发现它其实是很常见的一种应用二分查找的题型。 二分查找是在，前面的如果能满足，后面的一定能满足，的条件下才能使用。再来看这道题，如果 每份米的最大值 最小不超过10，那 每份米的最大值 最小是不是肯定不超过比10大的数？是的，那么它就可以使用二分查找。 接下来说说怎么用，也就是二分查找的Check()函数怎么写。我们在放隔板的时候，因为米堆的顺序固定，所以一旦某一堆的和+a[i]超过了k，我们就得在a[i]之前放一个隔板。也就是说，我们可以在循环1-n时，每次累加当前米堆的和，当它要超过k时，隔板数+1。如果某时刻隔板数&gt;m，你就知道，米堆最大值最小是k这个条件，是无法满足的，return false。 下面是具体的代码实现。 1234567891011121314151617181920212223242526272829303132333435bool Check(int x)&#123; int sum=0,cnt=0; ufor (i,1,n) &#123; if (sum+a[i]&gt;x) sum=a[i],cnt++; else sum+=a[i]; &#125; return cnt+1&lt;=m;&#125;int main()&#123; while (scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) &#123; int summ=0,maxx=0; ufor (i,1,n) &#123; scanf(\"%d\",&amp;a[i]); summ+=a[i]; maxx=max(maxx,a[i]); &#125; int l=maxx,r=summ; while (l&lt;r) &#123; int mid=(l+r)/2; if (Check(mid)) r=mid; else l=mid+1; &#125; //printf(\"%d\\n\",r); //while (!Check(r)) r--; cout&lt;&lt;l&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"计算思维训练-20200708","slug":"计算思维训练-20200708","date":"2020-07-08T01:49:33.000Z","updated":"2020-07-08T01:49:33.845Z","comments":true,"path":"2020/07/08/计算思维训练-20200708/","link":"","permalink":"http://yoursite.com/2020/07/08/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200708/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"计算思维训练-20200707","slug":"计算思维训练-20200707","date":"2020-07-07T08:21:27.000Z","updated":"2020-07-08T03:49:31.468Z","comments":true,"path":"2020/07/07/计算思维训练-20200707/","link":"","permalink":"http://yoursite.com/2020/07/07/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200707/","excerpt":"","text":"Problem F. 安全的密码mark text时间限制 1000 ms内存限制 256 MB 题目描述众所周知，密码安全是互联网时代人们最为关心的事情之一。而 RSA 公钥加密算法是目前最有影响力和最常用的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击。 其实 RSA 公钥加密算法的原理并不复杂，它基于一个十分简单的数论事实：将两个大素数相乘十分容易，而想要对其乘积进行质因数分解却极其困难，因此可以将乘积公开作为加密密钥。 所以 RSA 算法很重要的一个过程就是得到两个大素数相乘结果。 wchhlbt 和 Lazy_sheep 想要模拟一下 RSA 算法的加密过程。现在 wchhlbt拿到了 Lazy_sheep 提供的一份素数相乘的结果，但是 Lazy_sheep 因为别的事情计算的并不认真。 所以 wchhlbt 希望你来帮他判断这些数据的正确性。 输入数据第一行为一个整数 t (1≤t≤1000)，表示数据的组数。接下来对于每组数据：第一行为一个整数 n (2≤n≤2×109)。 输出数据对于每组数据，输出一行：如果这个数可以分解为两个素数乘积，输出YES，否则输出NO。 样例输入46835121样例输出YESNOYESYES样例说明无 算法 一个数学题，绕过了一道弯，写得好的代码应该在二十行左右。对于每一个N，我们首先要想，如果它是两个素数的乘积，它一定满足什么条件？两个素数的乘积，一定不会是其他素数的倍数。如果一个数是两个大于一百的素数的乘积，它还有可能是2的倍数吗？不可能。这说明什么？如果n是两个素数的乘积，一旦我们找到了n的一个约数x，它的另一个约数就找到了（也就是n/x），而n不会再有其他约数，也就是循环不用继续下去。 那么这道题的做法也就显而易见。我们从2到(int)sqrt(n)循环，一旦找到一个n的约数x，就看n/x是不是素数。是素数，就是YES，不然就是NO。BTW，这里x是不是素数是不用判断的。原因是____. 1234567891011121314151617int main()&#123; scanf(\"%d\",&amp;T); while (T--) &#123; scanf(\"%d\",&amp;n); bool flag=false; ufor (i,2,(int) sqrt(n)) if (n%i==0) &#123; if (Sushu(n/i)) flag=true; break; &#125; printf((flag)? \"YES\\n\":\"NO\\n\"); &#125; return 0;&#125; 思考题：在以上的for循环中，为什么要写两个if，而不是在两个判断之间用&amp;&amp;? Problem G. 课堂作业-4-4时间限制 1000 ms内存限制 64 MB 题目描述小明刚买了一个机械键盘，但他在用机械键盘打字的时候发现键盘的Home键和End键坏掉了，于是他在打字的时候光标有时会突然跑到行首，有时又会突然跑到行尾，现在给你键盘的输入，求最后屏幕上的字符串。 输入数据输入数据为一行字符串，字符串只包含小写英文字母,’[‘符号以及’]’符号，’[‘代表按下了Home键，‘]’代表按下了End键，字符串长度不超过100000。 输出数据输出最后屏幕上的字符串。 样例输入 xiechengxuz[henhao]wan 样例输出 henhaoxiechengxuzwan 样例说明可能出现多个’[‘和’]’，也可能没有’[‘和’]’ 解法 在说解法之前，先来捋一捋这题是什么意思。对于一个更典型的样例 1[dsafd]af[daf]ewa[]f[ds 它的输出应当是 1dsdafdsafdafewaf 这是怎么出来的呢？在队首，先有dsafd，然后daf插到它前面去了，接着ds又在它俩前面，所以输出的前面部分是dsdafdsafd。然后是中间部分。这里有一个结论，是中间部分必然在所有的[和]之前。输出中间部分（本样例无）之后，是队尾部分。队尾先有af，然后ewa排在它后面，f也在后面。所以最终输出为dsdafdsafdafewaf。 这题通过和大佬们讨论，本菜鸡获得了三个方法。以下引用均已获得许可。 一、strcat by JJHDL其实这道题麻烦的地方就在队首而已。然后strcat是一个在时间复杂度上正常，而在代码编写难易程度上出色的一个函数。对于上面那个样例，我们就是把daf用strcat插到前面，再把ds插到前面。这个比较好理解，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int main(void)&#123; scanf(\"%s\",s); int len = strlen(s); ans[0] = '\\0'; tmp[0] = '\\0'; int top = -1; int last = -1; for (int i=0;i&lt;len;i++) &#123; if (s[i]=='[') &#123; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; top=-1; last = 1; continue; &#125; if (s[i]==']') &#123; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; top = -1; last = -1; continue; &#125; tmp[++top] = s[i]; &#125; tmp[top+1]='\\0'; if (last==-1)&#123; strcat(ans,tmp); &#125;else&#123; strcat(tmp,ans); strcpy(ans,tmp); &#125; printf(\"%s\\n\",ans); return 0;&#125; 该做法与链表类似。 二、倒序存 by GlisCJ我对于队首的处理方法是这样的：首先，在样例中，在队首的那几个字符串是 dsafd daf ds 是比较容易得到的。然后我们如何能更直接地存储它们呢？我想到一个方法，就是把每个分开的队首字符串都倒着存，这样会得到dfasd fad sd 。再把这个字符串倒序输出，就是 dsdafdsafd ，也就是我们想要的答案。这个也比较好理解，代码如下： 123456789101112131415161718192021222324252627282930int main()&#123; scanf(\"%s\",s); n=strlen(s); int i=0; while (i&lt;n) &#123; while (s[i]=='[') &#123; int x=0; while (s[i]=='[') i++; while (i&lt;n &amp;&amp; s[i]!=']' &amp;&amp; s[i]!='[') a[x++]=s[i++]; dfor (j,x-1,0) st[cur++]=a[j]; &#125; i++; &#125; dfor (i,cur-1,0) printf(\"%c\",st[i]); i=0; while (i&lt;n) &#123; while (s[i]=='[' || s[i]==']') &#123; while (s[i]=='[') while (i&lt;n &amp;&amp; s[i]!=']') i++; while (s[i]==']' &amp;&amp; i&lt;n) i++; &#125; if (i&gt;=n) break; putchar(s[i++]); &#125; return 0;&#125; 然鹅我实在是太菜惹，把它当成了传统字符串处理题。楼下简直是模板。 三、deque by ZXDL队首，其实是相当于把一个个字符串不断放在第一位。队尾，其实是相当于把一个个字符串不断放在最后一位。那这就和stl中的deque的push_front()、push_back()操作完全吻合。这道题就像是这种数据结构的模板题，所以代码会非常清晰简明。这个也比较好理解，代码如下： 1234567891011121314151617181920int main() &#123; char buf[102400]; std::deque&lt;std::string&gt; input; scanf(\"%[^][\\n]\", buf); input.push_back(std::string(buf)); char c; while (c = getchar(), c != EOF) &#123; buf[0] = 0; if (c == '[') &#123; scanf(\"%[^][\\n]\", buf); input.push_front(std::string(buf)); &#125; else if (c == ']') &#123; scanf(\"%[^][\\n]\", buf); input.push_back(std::string(buf)); &#125; &#125; for (auto &amp; i : input) &#123; std::cout &lt;&lt; i; &#125;&#125; 如果还是找不到错误原因的话，可以看看是不是在很多个[[[]]]]]][][][][][[[[]]]]相连的时候出错了。 友情链接：章鱼哥：https://fishercat.top/姜总：https://jjhqwq.top/","categories":[],"tags":[]},{"title":"计算思维综合训练_2020_07_06","slug":"计算思维训练-20200706","date":"2020-07-06T09:04:29.000Z","updated":"2020-07-06T11:58:35.486Z","comments":true,"path":"2020/07/06/计算思维训练-20200706/","link":"","permalink":"http://yoursite.com/2020/07/06/%E8%AE%A1%E7%AE%97%E6%80%9D%E7%BB%B4%E8%AE%AD%E7%BB%83-20200706/","excerpt":"","text":"Problem J. sqy 的锡纸烫时间限制 1000 ms内存限制 64 MB 题目描述渣男锡纸烫！ 前不久 sqy 老师花了大价钱，去做了一个帅气的锡纸烫。有着商业眼光的 sqy 一下子发现了大商机，于是他自己开了一家美容美发店。 sqy 找了刚刚做完纹理烫的大预言家 cbj 预测了未来，发现每个顾客都只在白天来美发店，并且第一次来店里的时候都会充一次价值 xi 的卡，然后从第二天开始，每天白天都会来这里打理头发，而 sqy 仅收取成本价 1 元钱来吸引顾客，直到把卡掏空为止，这个顾客就再也不会回来。 黑心商人 sqy 找大预言家要来了每个顾客的充卡时间和充值金额，他准备在某一天晚上跑路，他想知道自己最多能卷走多少钱。 输入数据第一行包括一个整数 n(1≤n≤1e5) 表示有 n 个顾客。 接下来共 n 行，每i+1行包括两个整数 xi,yi 表示第 xi 天一个顾客来充值了 yi 元 (1≤xi≤1e6,0≤yi≤231−1)。 输出数据输出一行包括一个整数 ans，表示 sqy 最多能卷走多少钱。 样例输入51 52 53 54 55 5样例输出15样例说明在第五天的时候，第一个人消费4元还剩1元，第二个人消费3元还剩2元，第三个人消费2元还剩3元，第四个人消费1元还剩4元，第五个人还没有开始消费就被卷钱跑路了。 算法差分 首先介绍一下朴素的差分。我们有n个数，m个操作。设0&lt;=n,m&lt;=1e5。n个数和m个操作在读入中给出。m个操作的形式为三个正整数 l r x，表示将这n个数中的第l个到第r个都分别加上x。然后有n次询问，询问第p到第q个数之间所有数字的和为多少？ 比如当n=5,m=3原数列:5 7 6 2 4操作:1 3 24 4 73 5 1则最终数列为：7 9 9 10 5 对于这道题，如果我们朴素地对每个操作，都从l到r循环，给a[i]加上x的话，时间复杂度会是O(nm)&gt;1e8，造成超时(time limit exceeded)。于是差分就出现了。 差分，就是在区间的开头和结尾分别打上标记的一种操作。比如在这道题中，我们称原数组为a，标记数组为b。对于每个操作，我们让b[l]+=x,b[r+1]-=x;这么做有什么用呢？我们观察b的前缀和数组。 前缀和数组sum[i]的值就等于经过m次操作，从1到i位的数之和增大了多少。那么如何求l~r的数之和增大了多少呢？显然为sum[r+1]-sum[l]。 于是，对于每个询问，我们只需要输出原数组在l、r+1的前缀和之差 加上 b数组在l、r+1的前缀和之差。 那么，如何将差分运用到sqy的锡纸烫这道题呢？首先，要从题目给出的数据范围揣摩算法。我们看到一个有点反常的地方：(1≤xi≤1e6,0≤yi≤2^31−1)。为什么xi和yi的最大值差那么远呢？因为xi最大也不超过1e6，所以我们可以从这里入手。 首先，感性认识一下可以确定，sqy获得最多钱的那一天，一定是某位客人刚办卡而没开始消费的一天，也就是某个x[i]。那我们就可以从min x[i]到max x[i]循环。在这个循环中，有三个变量参与，它们分别是：cnt(i天有多少客人消费)、now(i天sqy手中的钱)、ans（我们要输出的值）。 123456for (i,？,？) &#123; cnt+=c[i]; now+=b[i]; now-=cnt; ans=max(ans,now); &#125; 既然cnt是i天有多少客人消费的前缀和，那么c显然就是某天有多少人消费的标记数组。b数组同理。具体的代码实现请继续思考。奥力给！ 友情链接：章鱼哥：https://fishercat.top/姜总：https://jjhqwq.top/","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-03-12T02:51:24.479Z","updated":"2020-03-12T02:51:24.479Z","comments":true,"path":"2020/03/12/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}